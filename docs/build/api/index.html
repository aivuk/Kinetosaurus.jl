<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · JMAKi Documentation</title><meta name="title" content="API · JMAKi Documentation"/><meta property="og:title" content="API · JMAKi Documentation"/><meta property="twitter:title" content="API · JMAKi Documentation"/><meta name="description" content="Documentation for JMAKi Documentation."/><meta property="og:description" content="Documentation for JMAKi Documentation."/><meta property="twitter:description" content="Documentation for JMAKi Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JMAKi Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JMAKi Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">JMAKi - Julia Model-based Analyses of microbial Kinetics</a></li><li><a class="tocitem" href="../01_install/">Installation &amp; requirements</a></li><li><a class="tocitem" href="../02_data/">Data and annotation formatting</a></li><li><a class="tocitem" href="../03_main/">The main functions of JMAKi</a></li><li><a class="tocitem" href="../04_math/">The mathematical models</a></li><li><a class="tocitem" href="../05_examples/">Examples and Tutorial</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Pre-processing-functions"><span>Pre-processing functions</span></a></li><li><a class="tocitem" href="#Fitting-one-kinetics"><span>Fitting one kinetics</span></a></li><li><a class="tocitem" href="#Plot-a-file"><span>Plot a file</span></a></li><li><a class="tocitem" href="#Fitting-one-a-.csv-file"><span>Fitting one a .csv file</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Various"><span>Various</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ang-one/JMAKi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ang-one/JMAKi.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Pre-processing-functions"><a class="docs-heading-anchor" href="#Pre-processing-functions">Pre-processing functions</a><a id="Pre-processing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-processing-functions" title="Permalink"></a></h2><h3 id="Smoothing-data"><a class="docs-heading-anchor" href="#Smoothing-data">Smoothing data</a><a id="Smoothing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Smoothing-data" title="Permalink"></a></h3><p><a href="#JMAKi.smoothing_data"><code>JMAKi.smoothing_data</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.smoothing_data" href="#JMAKi.smoothing_data"><code>JMAKi.smoothing_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothing_data(
data::Matrix{Float64};
method=&quot;rolling_avg&quot;,
pt_avg=7,
thr_lowess=0.05
)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>data</code>: Matrix of data 2xn_time points, it is a single curve.</li><li><code>method=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li></ul><p><strong>Output:</strong></p><ul><li><code>data_fin</code>, array of smoothed data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/pre_processing_functions.jl#L58-L76">source</a></section></article><h3 id="Correction-for-multiple-scattering"><a class="docs-heading-anchor" href="#Correction-for-multiple-scattering">Correction for multiple scattering</a><a id="Correction-for-multiple-scattering-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-for-multiple-scattering" title="Permalink"></a></h3><p><a href="#JMAKi.correction_OD_multiple_scattering"><code>JMAKi.correction_OD_multiple_scattering</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.correction_OD_multiple_scattering" href="#JMAKi.correction_OD_multiple_scattering"><code>JMAKi.correction_OD_multiple_scattering</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">correction_OD_multiple_scattering(
data::Matrix{Float64},
calibration_curve::String;
method=&quot;interpolation&quot;
)</code></pre><p>Does the multiple scattering correction of one time series</p><p><strong>Arguments:</strong></p><ul><li><code>data</code>:  matrix of data 2xn_time points, it is a single curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>method</code>: String, How perform the inference of multiple scattering curve, options: &#39;&quot;interpolation&quot;&#39; or   &#39;&quot;exp_fit&quot;&#39; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li></ul><p><strong>Output:</strong></p><ul><li>&#39;data_fin&#39; corrected data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/pre_processing_functions.jl#L3-L20">source</a></section></article><h2 id="Fitting-one-kinetics"><a class="docs-heading-anchor" href="#Fitting-one-kinetics">Fitting one kinetics</a><a id="Fitting-one-kinetics-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-one-kinetics" title="Permalink"></a></h2><h3 id="Log-Lin-fitting"><a class="docs-heading-anchor" href="#Log-Lin-fitting">Log-Lin fitting</a><a id="Log-Lin-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Log-Lin-fitting" title="Permalink"></a></h3><p><a href="#JMAKi.fitting_one_well_Log_Lin"><code>JMAKi.fitting_one_well_Log_Lin</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fitting_one_well_Log_Lin" href="#JMAKi.fitting_one_well_Log_Lin"><code>JMAKi.fitting_one_well_Log_Lin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitting_one_well_Log_Lin(
data::Matrix{Float64},
name_well::String,
label_exp::String; 
display_plots=false,
save_plot=false,
path_to_plot=&quot;NA&quot;, 
type_of_smoothing=&quot;rolling_avg&quot;
pt_avg=7, 
pt_smoothing_derivative=7, 
pt_min_size_of_win=7, 
type_of_win=&quot;maximum&quot;,
threshold_of_exp=0.9, 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
thr_lowess=0.05, 
)</code></pre><p>This function fits a logarithmic-linear model to a single well&#39;s data. It evaluate the specific growht rate, the with a statistical threshold it individuates a exponetial window and perform a-log lin fitting</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>save_plot=false</code> :Bool, save the plot or not</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li></ul><p><strong>Output:</strong></p><ul><li>an array with the following contents:</li></ul><p><code>results_lin_log_fit = [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]</code></p><ul><li>The plots of the log-linear fitting and of the dynamics of specific growth rate if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L3-L54">source</a></section></article><h3 id="ODE-fitting"><a class="docs-heading-anchor" href="#ODE-fitting">ODE fitting</a><a id="ODE-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-fitting" title="Permalink"></a></h3><h4 id="Fitting-a-harcoded-model"><a class="docs-heading-anchor" href="#Fitting-a-harcoded-model">Fitting a harcoded model</a><a id="Fitting-a-harcoded-model-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-a-harcoded-model" title="Permalink"></a></h4><p><a href="#JMAKi.fitting_one_well_ODE_constrained"><code>JMAKi.fitting_one_well_ODE_constrained</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fitting_one_well_ODE_constrained" href="#JMAKi.fitting_one_well_ODE_constrained"><code>JMAKi.fitting_one_well_ODE_constrained</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitting_one_well_ODE_constrained(
data::Matrix{Float64},
name_well::String, 
label_exp::String, 
model::String, 
lb_param::Vector{Float64},
ub_param::Vector{Float64};
param=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
display_plots=true, 
save_plot=false,
path_to_plot=&quot;NA&quot;, 
pt_avg=1, 
pt_smooth_derivative=7,
smoothing=false,
type_of_smoothing=&quot;rolling_avg&quot;,
type_of_loss=&quot;RE&quot;,
blank_array=zeros(100), 
multiple_scattering_correction=false,
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
)</code></pre><p>This function performs fitting on a single well&#39;s data using an ordinary differential equation (ODE) model. It estimates the model parameters within specified lower and upper bounds.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>model::String</code>: ODE model to use</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p><strong>Output (if <code>results_ODE_fit =fitting_one_well_ODE_constrained(...)</code>:</strong></p><ul><li><code>results_ODE_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code></li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected ODE as in the documentation.</p><ul><li><code>results_ODE_fit[2]</code> the times of the fitted ODE</li><li><code>results_ODE_fit[3]</code> the numerical solution of the fitted ODE</li><li>The plot of the  fitting  if <code>do_plot=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L274-L343">source</a></section></article><h4 id="Fitting-a-custom-model"><a class="docs-heading-anchor" href="#Fitting-a-custom-model">Fitting a custom model</a><a id="Fitting-a-custom-model-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-a-custom-model" title="Permalink"></a></h4><p><a href="#JMAKi.fitting_one_well_custom_ODE"><code>JMAKi.fitting_one_well_custom_ODE</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fitting_one_well_custom_ODE" href="#JMAKi.fitting_one_well_custom_ODE"><code>JMAKi.fitting_one_well_custom_ODE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitting_one_well_custom_ODE(
data::Matrix{Float64}
name_well::String, 
label_exp::String, 
model::Any, 
lb_param::Vector{Float64},
ub_param::Vector{Float64},
n_equation::Int;
param=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
display_plots=false, 
save_plot=false,
path_to_plot=&quot;NA&quot;, 
pt_avg=1, 
pt_smooth_derivative=0,
smoothing=false, 
type_of_loss=&quot;RE&quot;,
blank_array=zeros(100), 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
type_of_smoothing=&quot;lowess&quot;,
)</code></pre><p>This function is designed for fitting an ordinary differential equation (ODE) model to a dataset representing the growth curve of a microorganism in a well.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>model::Any</code>: Function of the ODE to be fitted. See the documentation for examples.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li><li><code>n_equation::Int</code>:  number ode in the system</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p><strong>Output (if <code>results_ODE_fit =fitting_one_well_custom_ODE(...)</code>:</strong></p><ul><li><code>results_ODE_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code></li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the used ODE.</p><ul><li>The plot of the  fitting  if <code>do_plot=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L478-L548">source</a></section></article><h4 id="ODE-model-selection"><a class="docs-heading-anchor" href="#ODE-model-selection">ODE model selection</a><a id="ODE-model-selection-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-model-selection" title="Permalink"></a></h4><p><a href="#JMAKi.ODE_Model_selection"><code>JMAKi.ODE_Model_selection</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.ODE_Model_selection" href="#JMAKi.ODE_Model_selection"><code>JMAKi.ODE_Model_selection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ODE_Model_selection(
data::Matrix{Float64},
name_well::String,
label_exp::String, 
models_list::Vector{String}, 
lb_param_array::Any, 
ub_param_array::Any; 
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
pt_avg=1,
beta_penality=2.0,
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
type_of_loss=&quot;L2&quot;,
blank_array=zeros(100),
display_plot_best_model=false, 
save_plot_best_model=false,
path_to_plot=&quot;NA&quot;,
pt_smooth_derivative=7,
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
verbose=false,
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
correction_AIC=true,)</code></pre><p>This function performs model selection based on a dataset representing the growth curve of a microorganism in a well. It evaluates multiple ODE models and selects the best-fitting model using the Akaike Information Criterion (AIC) or corrected AIC (AICc).</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>models_list::Vector{String}</code>: list of ODE model used</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>models_list::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>lb_param_array::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>ub_param_array::Any</code>: Upper bounds for the parameters (compatible with the models).</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot_best_model=false</code> :Bool, save the plot or not.</li><li><code>display_plot_best_model=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li></ul><p><strong>Output (if <code>Model_selection =ODE_Model_selection(...)</code>:</strong></p><ul><li><code>Model_selection[1]</code> a Matrix containing the loss and the AIC score for each model.</li><li><code>Model_selection[2]</code> a Tuple containing all the fitted models.</li><li><code>Model_selection[3]</code> the AIC score of the best model.</li><li><code>Model_selection[4]</code> , the loss of the best model.</li><li><code>Model_selection[5]</code> , the parameter of the best model.</li><li><code>Model_selection[6]</code> , the string of the best model.</li><li><code>Model_selection[7]</code> , the numerical solution of the fitted ODE.</li><li>The plot of the  fitting of the best model if <code>save_plot_best_model=true</code> or  <code>display_plot_best_model=true</code> .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L678-L755">source</a></section></article><h4 id="ODE-Morris-sensitivity"><a class="docs-heading-anchor" href="#ODE-Morris-sensitivity">ODE Morris sensitivity</a><a id="ODE-Morris-sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-Morris-sensitivity" title="Permalink"></a></h4><p><a href="#JMAKi.one_well_morris_sensitivity"><code>JMAKi.one_well_morris_sensitivity</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.one_well_morris_sensitivity" href="#JMAKi.one_well_morris_sensitivity"><code>JMAKi.one_well_morris_sensitivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">one_well_morris_sensitivity(
data::Matrix{Float64},
name_well::String, 
label_exp::String, 
model::String,
lb_param::Vector{Float64}, 
ub_param::Vector{Float64};
N_step_morris=7,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(),
pt_avg=1, 
pt_smooth_derivative=7,
write_res=false,
smoothing=false, 
type_of_smoothing=&quot;lowess&quot;,
type_of_loss=&quot;RE&quot;, 
blank_array=zeros(100), 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
)</code></pre><p>This function is designed to perform Morris sensitivity analysis on a dataset representing the growth curve of a microorganism in a well. It assesses the sensitivity of the model to variations in input parameters of the optimization.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>model::String</code>: The ODE model to use.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds for the parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds for the parameters.</li></ul><p><strong>Key Arguments:</strong></p><pre><code class="nohighlight hljs">- `N_step_morris=7`: Number of steps for the Morris sensitivity analysis.</code></pre><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p><strong>Output (if <code>results_ODE_morris_sensitivity =one_well_morris_sensitivity(...)</code>:</strong></p><ul><li><code>results_ODE_morris_sensitivity[1]</code> a with in each column the initial guess for the parameters of the optimization in the same order of <a href="#ODE_list">table</a></li><li><code>results_ODE_morris_sensitivity[2]</code> a matrix with the following contents for each column: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code>. It can be saved into a .csv if <code>write_res=true</code>.</li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param<em>n&quot; &#39; are the parameter of the selected ODE as in this [table](#ODE</em>list)</p><ul><li>The plot of the  fitting of the best model if <code>save_plot_best_model=true</code> or  <code>display_plot_best_model=true</code> .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L976-L1043">source</a></section></article><h3 id="NL-Fitting"><a class="docs-heading-anchor" href="#NL-Fitting">NL Fitting</a><a id="NL-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#NL-Fitting" title="Permalink"></a></h3><h3 id="NL-Fitting-2"><a class="docs-heading-anchor" href="#NL-Fitting-2">NL Fitting</a><a class="docs-heading-anchor-permalink" href="#NL-Fitting-2" title="Permalink"></a></h3><p><a href="#JMAKi.fit_NL_model"><code>JMAKi.fit_NL_model</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model" href="#JMAKi.fit_NL_model"><code>JMAKi.fit_NL_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_NL_model(
data::Matrix{Float64}, 
name_well::String,
label_exp::String, 
model_function::Any, 
lb_param::Vector{Float64}, 
ub_param::Vector{Float64}; 
u0=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
display_plots=true, 
save_plot=false,
path_to_plot=&quot;NA&quot;, 
pt_avg=1, 
pt_smooth_derivative=7,
smoothing=false, 
type_of_smoothing=&quot;rolling_avg&quot;,
type_of_loss=&quot;RE&quot;, 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
penality_CI=3.0,
)</code></pre><p>This function performs fitting on a single well&#39;s data using an any NL function . </p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>model_function::String</code>: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_model(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation.</li><li><code>results_NL_fit[2]</code> the numerical solution of the fitted ODE</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L4-L69">source</a></section></article><p><a href="#JMAKi.fit_NL_model_with_sensitivity"><code>JMAKi.fit_NL_model_with_sensitivity</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model_with_sensitivity" href="#JMAKi.fit_NL_model_with_sensitivity"><code>JMAKi.fit_NL_model_with_sensitivity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_NL_model_with_sensitivity(
data::Matrix{Float64}, 
name_well::String,
label_exp::String, 
model_function::Any, 
lb_param::Vector{Float64}, 
ub_param::Vector{Float64};
nrep=100,
u0=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
display_plots=true, 
save_plot=false,
path_to_plot=&quot;NA&quot;, 
pt_avg=1, 
pt_smooth_derivative=7,
smoothing=false, 
type_of_smoothing=&quot;rolling_avg&quot;,
type_of_loss=&quot;RE&quot;, 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
penality_CI=3.0,
)</code></pre><p>This function performs fitting Morris sensitivity analysis on a single well&#39;s data using a NL function. </p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>model_function::String</code>: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>nrep=100</code>. Number of Morris steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_model_with_sensitivity(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[2]</code>: the parameter of the best fit </li><li><code>results_NL_fit[3]</code>: the results of the fit for any combination tested.</li></ul><p>-<code>results_NL_fit[4]</code>: the results of the fit for any combination tested.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L204-L272">source</a></section></article><p><a href="#JMAKi.fit_NL_model_MCMC_intialization"><code>JMAKi.fit_NL_model_MCMC_intialization</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model_MCMC_intialization" href="#JMAKi.fit_NL_model_MCMC_intialization"><code>JMAKi.fit_NL_model_MCMC_intialization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit<em>NL</em>model<em>MCMC</em>intialization(     data::Matrix{Float64},      name<em>well::String,     label</em>exp::String,      model<em>function::Any,      lb</em>param::Vector{Float64},      ub<em>param::Vector{Float64};     nrep=100,     u0=lb</em>param .+ (ub<em>param .- lb</em>param) ./ 2,     optmizator=BBO<em>adaptive</em>de<em>rand</em>1<em>bin</em>radiuslimited(),     display<em>plots=true,      save</em>plot=false,     path<em>to</em>plot=&quot;NA&quot;,      pt<em>avg=1,      pt</em>smooth<em>derivative=7,     smoothing=false,      type</em>of<em>smoothing=&quot;rolling</em>avg&quot;,     type<em>of</em>loss=&quot;RE&quot;,      multiple<em>scattering</em>correction=false,      method<em>multiple</em>scattering<em>correction=&quot;interpolation&quot;,     calibration</em>OD<em>curve=&quot;NA&quot;,       PopulationSize=300,     maxiters=2000000,     abstol=0.00001,     thr</em>lowess=0.05,     penality_CI=3.0,     )</p><p>This function performs NL fitting. It tries to automatically detect the optimal starting guess of the parameters by using a Markov Chain Montecarlo restart of the intial guess.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>model_function::String</code>: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_model_MCMC_intialization(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[2]</code>: the array of the best fit </li><li><code>results_NL_fit[3]</code>: the chain of all proposed solutions losses</li></ul><p>-<code>results_NL_fit[4]</code>: the chain of the best losses</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L445-L512">source</a></section></article><p><a href="#JMAKi.fit_NL_model_bootstrap"><code>JMAKi.fit_NL_model_bootstrap</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model_bootstrap" href="#JMAKi.fit_NL_model_bootstrap"><code>JMAKi.fit_NL_model_bootstrap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit<em>NL</em>model<em>bootstrap(     data::Matrix{Float64},      name</em>well::String,     label<em>exp::String,      model</em>function::Any,      lb<em>param::Vector{Float64},      ub</em>param::Vector{Float64};     nrep=100,     u0=lb<em>param .+ (ub</em>param .- lb<em>param) ./ 2,     optmizator=BBO</em>adaptive<em>de</em>rand<em>1</em>bin<em>radiuslimited(),     display</em>plots=true,      save<em>plot=false,     path</em>to<em>plot=&quot;NA&quot;,      pt</em>avg=1,      size<em>bootstrap=0.7,     pt</em>smooth<em>derivative=7,     smoothing=false,      type</em>of<em>smoothing=&quot;rolling</em>avg&quot;,     type<em>of</em>loss=&quot;RE&quot;,      multiple<em>scattering</em>correction=false,      method<em>multiple</em>scattering<em>correction=&quot;interpolation&quot;,     calibration</em>OD<em>curve=&quot;NA&quot;,       PopulationSize=300,     maxiters=2000000,     abstol=0.00001,     thr</em>lowess=0.05,     penality_CI=3.0,     )</p><p>This function performs NL fitting. It perform nrep iterations of Bootstrap to evaluate the confidence intervals and  avoid bad initializations.</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>model_function::String</code>: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_model_bootstrap(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[2]</code>: the array of the best fit </li><li><code>results_NL_fit[3]</code>:parameters </li></ul><p>-<code>results_NL_fit[4]</code>: parameters -<code>results_NL_fit[5]</code>: mean best parameters -<code>results_NL_fit[6]</code>: std best parameters -<code>results_NL_fit[7]</code>:CI lower bound -<code>results_NL_fit[8]</code>:CI upper bound</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L705-L778">source</a></section></article><p><a href="#JMAKi.NL_error_blanks"><code>JMAKi.NL_error_blanks</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.NL_error_blanks" href="#JMAKi.NL_error_blanks"><code>JMAKi.NL_error_blanks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NL_error_blanks(data::Matrix{Float64}, 
name_well::String, 
label_exp::String, 
model_function::Any,
lb_param::Vector{Float64},
ub_param::Vector{Float64},
blank_array::Vector{Float64}; 
nrep=100,
u0=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
display_plots=false, 
save_plot=false,
path_to_plot=&quot;NA&quot;, 
pt_avg=1, 
pt_smooth_derivative=7,
smoothing=false,
type_of_smoothing=&quot;rolling_avg&quot;,
type_of_loss=&quot;RE&quot;, 
multiple_scattering_correction=false,
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
write_res=false,
penality_CI=3.0
)</code></pre><p>This function performs NL fitting. It perform nrep iterations to estimate the posterior distribuition of parameters fitting. It uses the blank distribution as noise.</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>model_function::String</code>: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li></ul><p><strong>Output (if <code>results_NL_fit =NL_error_blanks(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[2]</code>: the array of the best fit </li><li><code>results_NL_fit[3]</code>:parameters </li></ul><p>-<code>results_NL_fit[4]</code>: parameters -<code>results_NL_fit[5]</code>: mean best parameters -<code>results_NL_fit[6]</code>: std best parameters -<code>results_NL_fit[7]</code>:CI lower bound -<code>results_NL_fit[8]</code>:CI upper bound</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L965-L1038">source</a></section></article><h4 id="NL-Model-selection"><a class="docs-heading-anchor" href="#NL-Model-selection">NL Model selection</a><a id="NL-Model-selection-1"></a><a class="docs-heading-anchor-permalink" href="#NL-Model-selection" title="Permalink"></a></h4><p><a href="#JMAKi.NL_model_selection"><code>JMAKi.NL_model_selection</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.NL_model_selection" href="#JMAKi.NL_model_selection"><code>JMAKi.NL_model_selection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NL_model_selection(data::Matrix{Float64}, 
name_well::String,
label_exp::String, 
list_model_function::Any, 
list_lb_param::Any, 
list_ub_param::Any; 
method_of_fitting=&quot;MCMC&quot;,
nrep=100,
list_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
display_plots=true, 
save_plot=false,
size_bootstrap=0.7,
path_to_plot=&quot;NA&quot;,
pt_avg=1,
pt_smooth_derivative=7,
smoothing=false, 
type_of_smoothing=&quot;rolling_avg&quot;,
type_of_loss=&quot;RE&quot;, 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
write_res=false,
beta_param=2.0,
penality_CI=8.0,
correction_AIC=false,
)</code></pre><p>This function performs NL model selection of an array of NL models, it uses AIC or AICc depending on user inputs. It perform nrep iterations to estimate the posterior distribuition of parameters fitting. It uses the blank distribution as noise.</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>list_model_function::Any</code>: Array containing functions or strings of the NL models</li><li><code>list_lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li></ul><p><strong>Output (if <code>results_NL_fit =NL_model_selection(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[2]</code>: an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected model as in the documentation. This for the fit with less loss.</li><li><code>results_NL_fit[3]</code>: the array of best fit </li></ul><p>-<code>results_NL_fit[4]</code>: scores of the models -<code>results_NL_fit[5]</code>: the loss of the best loss</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L1232-L1309">source</a></section></article><h3 id="Segmented-fitting"><a class="docs-heading-anchor" href="#Segmented-fitting">Segmented fitting</a><a id="Segmented-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Segmented-fitting" title="Permalink"></a></h3><h4 id="ODE-segmentation"><a class="docs-heading-anchor" href="#ODE-segmentation">ODE segmentation</a><a id="ODE-segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-segmentation" title="Permalink"></a></h4><p><a href="#JMAKi.selection_ODE_fixed_intervals"><code>JMAKi.selection_ODE_fixed_intervals</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.selection_ODE_fixed_intervals" href="#JMAKi.selection_ODE_fixed_intervals"><code>JMAKi.selection_ODE_fixed_intervals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selection_ODE_fixed_intervals(
data_testing::Matrix{Float64}, 
name_well::String, 
label_exp::String, 
list_of_models::Vector{String}, 
list_lb_param::Any, 
list_ub_param::Any, 
intervals_changepoints::Any;
type_of_loss=&quot;L2&quot;, 
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
pt_avg=1,
save_plot=false, 
display_plots=false,
path_to_plot=&quot;NA&quot;, 
pt_smooth_derivative=7,
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
beta_smoothing_ms=2.0, 
PopulationSize=300,
maxiters=2000000,
abstol=0.0000000001,
correction_AIC=true)</code></pre><p>This function performs a fitting of a segmented ODE on one curve. For this function the user must supply the change points.</p><p><strong>Arguments:</strong></p><ul><li><code>data_testing::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>list_of_models::Vector{String}</code>: A vector of string of ODE models to evaluate.</li><li><code>list_lb_param::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>: Upper bounds for the parameters (compatible with the models).</li><li><code>intervals_changepoints::Any</code>: the array containings the change point list, e.g., [0.0 10.0 30.0] </li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot_best_model=false</code> :Bool, save the plot or not.</li><li><code>display_plot_best_model=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li></ul><p><strong>Output (if <code>res =selection_ODE_fixed_intervals(...)</code>:</strong></p><ul><li><code>res[1]</code>. Parameters of each segment</li><li><code>res[2]</code>. Interval of the ODE segment</li><li><code>res[3]</code>. Time of the fitted solution</li><li><code>res[4]</code>. Numerical fitted solution</li><li><code>res[5]</code>. the loss of the solution</li><li>The plot of the  fitting of the best model if <code>save_plot_best_model=true</code> or  <code>display_plot_best_model=true</code> .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L1164-L1241">source</a></section></article><p><a href="#JMAKi.segmentation_ODE"><code>JMAKi.segmentation_ODE</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.segmentation_ODE" href="#JMAKi.segmentation_ODE"><code>JMAKi.segmentation_ODE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segmentation_ODE(
data_testing::Matrix{Float64}, 
name_well::String, 
label_exp::String, 
list_of_models::Vector{String}, 
list_lb_param::Any,
list_ub_param::Any,
n_max_change_points::Int;
detect_number_cpd=true,
fixed_cpd=false,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
integrator=Tsit5(),
type_of_loss=&quot;L2&quot;,
type_of_detection=&quot;slinding_win&quot;,
type_of_curve=&quot;original&quot;,
pt_avg=1, 
smoothing=true, 
save_plot=false, 
display_plot=false,
path_to_plot=&quot;NA&quot;, 
path_to_results=&quot;NA&quot;,
win_size=14, 
pt_smooth_derivative=7,
penality_parameter=2.0,
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
save_all_model=false,
method_peaks_detection=&quot;peaks_prominence&quot;,
n_bins=40,
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
correction_AIC=true)</code></pre><p>This function performs model selection for ordinary differential equation (ODE) models while segmenting the time series in various part using change points detection algorithm.</p><p><strong>Arguments:</strong></p><ul><li><code>data_testing::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>list_of_models::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>list_lb_param::Any</code>: Array of lower bounds for the parameters of all models.</li><li><code>list_ub_param::Any</code>: Array of upper bounds for the parameters of all models.</li><li><code>n_max_change_points::Int</code>: Number of change point used, the results will have different number of cp depending on the values of key argument &#39;type<em>of</em>detection&#39; and &#39;fixed_cpd&#39;</li></ul><p><strong>Key Arguments:</strong></p><ul><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot_best_model=false</code> :Bool, save the plot or not.</li><li><code>display_plot_best_model=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &#39;&quot;interpolation&quot;&#39; or   &#39;&quot;exp_fit&quot;&#39; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li>&#39;type<em>of</em>detection=&quot;slinding<em>win&quot;&#39;: String, algorithm of cpd to use. Options &#39;&quot;slinding</em>win&quot;&#39; use a slinding window approach, &#39;&quot;lsdd&quot;&#39; uses least square density difference (LSDD) from ChangePointDetection.jl </li><li>&#39;type<em>of</em>curve=&quot;original&quot;&#39;: String, on which curve is performed the change point detection algorithm. If &#39;&quot;original&quot;&#39; it use the original time series. With &#39;&quot;deriv&quot;&#39; it use the specific growth rate time series to perform the cdp.</li><li><code>method_peaks_detection=&quot;peaks_prominence&quot;</code>: How the peak detection is performed on the dissimilarity curve.  <code>&quot;peaks_prominence&quot;</code> orders the peaks by prominence. <code>thr_scan</code> uses a threshold to choose the peaks</li><li><code>n_bins=40</code>: Int, used if <code>method_peaks_detection=&quot;thr_scan&quot;</code> number of bins used to generate the threshold that has n<em>change</em>points peaks</li><li>&#39;detect<em>number</em>cpd=true&#39;: Bool, if equal to true all the possible combination of lenght 1,2,...,n<em>change</em>points are tested and the best for AICc is returned.</li><li>&#39;fixed<em>cpd=false&#39;: Bool If  true it returns the fitting using top n</em>change_points.</li><li>&#39;win_size=14&#39;: Int, size of the windows used by the cdo algorithms</li><li>&#39;path<em>to</em>results=&quot;NA&quot;&#39;:String, where to save the results.</li><li>&#39;save<em>all</em>model=false&#39;: Bool, if true all the tested model are saved.</li></ul><p>Note that, if &#39;detect<em>number</em>cpd=false&#39; and &#39;fixed<em>cpd=false&#39; JMAKi will use n</em>change<em>points but it will test different combinations of the n</em>change_points+2 top change points</p><p><strong>Output (if <code>Model_selection =ODE_Model_selection(...)</code>:</strong></p><ul><li><code>res[1]</code>. Parameters of each segment</li><li><code>res[2]</code>. Interval of the ODE segment</li><li><code>res[3]</code>. Time of the fitted solution</li><li><code>res[4]</code>. Numerical fitted solution</li><li>The plot of the  fitting of the best model if <code>save_plot_best_model=true</code> or  <code>display_plot_best_model=true</code> .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_well_functions.jl#L1477-L1573">source</a></section></article><h4 id="NL-segmentation"><a class="docs-heading-anchor" href="#NL-segmentation">NL segmentation</a><a id="NL-segmentation-1"></a><a class="docs-heading-anchor-permalink" href="#NL-segmentation" title="Permalink"></a></h4><p><a href="#JMAKi.selection_NL_fixed_interval"><code>JMAKi.selection_NL_fixed_interval</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.selection_NL_fixed_interval" href="#JMAKi.selection_NL_fixed_interval"><code>JMAKi.selection_NL_fixed_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selection_NL_fixed_interval(
data_testing::Matrix{Float64},
name_well::String, 
label_exp::String, 
list_of_models::Vector{String}, 
list_lb_param::Any, 
list_ub_param::Any, 
intervals_changepoints::Any;
list_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,
type_of_loss=&quot;L2&quot;, 
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
method_of_fitting=&quot;MCMC&quot;,
smoothing=false,
size_bootstrap=0.7,
nrep=100,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
pt_avg=1,
pt_smooth_derivative=0,
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
beta_smoothing_ms=2.0,
PopulationSize=300,
maxiters=2000000,
abstol=0.000000001,
penality_CI=8.0,
correction_AIC=true,
)



This function performs a fitting of a segmented NL on one curve. For this function the user must supply the change points.</code></pre><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>list_model_function::Any</code>: Array containing functions or strings of the NL models</li><li><code>list_lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li><li><code>models_list::Vector{String}</code>: Array of  models to evaluate.</li><li><code>intervals_changepoints::Any</code>: the array containings the change point list, e.g., [0.0 10.0 30.0] </li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li></ul><p><strong>Output (if <code>results_NL_fit =selection_NL_fixed_interval(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code>. Parameters of each segment</li><li><code>results_NL_fit[2]</code>. The numerical solutions of the fit</li><li><code>results_NL_fit[3]</code>.  The time of the numerical solutions of the fit</li><li><code>results_NL_fit[4]</code>. the loss of the best loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L1615-L1693">source</a></section></article><p><a href="#JMAKi.selection_NL_max_change_points"><code>JMAKi.selection_NL_max_change_points</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.selection_NL_max_change_points" href="#JMAKi.selection_NL_max_change_points"><code>JMAKi.selection_NL_max_change_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">selection_NL_max_change_points(
data_testing::Matrix{Float64},
name_well::String, 
label_exp::String,
list_of_models::Any, 
list_lb_param::Any, 
list_ub_param::Any, 
n_change_points::Int;
list_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,
type_of_loss=&quot;L2_fixed_CI&quot;, 
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),
method_of_fitting=&quot;MCMC&quot;, 
type_of_detection=&quot;sliding_win&quot;,
type_of_curve=&quot;original&quot;,
smoothing=false,
nrep=100,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
pt_avg=1,
save_plot=false,
display_plots=false,
path_to_plot=&quot;NA&quot;, 
win_size=7, 
pt_smooth_derivative=0,
multiple_scattering_correction=false,
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
beta_smoothing_ms=2.0, 
method_peaks_detection=&quot;peaks_prominence&quot;,
n_bins=40,
PopulationSize=300,
maxiters=2000000,
abstol=0.000000001,
detect_number_cpd=false,
fixed_cpd=false,
penality_CI=8.0,
size_bootstrap=0.7,
correction_AIC=true
)</code></pre><p>This function performs model selection for NL models while segmenting the time series in various part using change points detection algorithm.</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>list_model_function::Any</code>: Array containing functions or strings of the NL models</li><li><code>list_lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li><li><code>models_list::Vector{String}</code>: Array of  models to evaluate.</li><li><code>intervals_changepoints::Any</code>: the array containings the change point list, e.g., [0.0 10.0 30.0] </li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li></ul><p><strong>Output (if <code>results_NL_fit =selection_NL_fixed_interval(...)</code>:</strong></p><ul><li><code>results_NL_fit[1]</code> an array with the following the parameters of each segment</li><li><code>results_NL_fit[2]</code>: the list of used change points</li><li><code>results_NL_fit[3]</code>:the numerical best solution</li></ul><p>-<code>results_NL_fit[4]</code>: the time of the numerical best solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_well.jl#L1854-L1940">source</a></section></article><h2 id="Plot-a-file"><a class="docs-heading-anchor" href="#Plot-a-file">Plot a file</a><a id="Plot-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-a-file" title="Permalink"></a></h2><p><a href="#JMAKi.plot_data"><code>JMAKi.plot_data</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.plot_data" href="#JMAKi.plot_data"><code>JMAKi.plot_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_data(
label_exp::String, 
path_to_data::String; 
path_to_annotation::Any = missing,
path_to_plot=&quot;NA&quot;,
display_plots=true,
save_plots=false,
overlay_plots=true, 
do_blank_subtraction=&quot;NO&quot;, vg)
avg_replicate=false, 
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01 ,
blank_value = 0.0,
blank_array = [0.0],
)</code></pre><p>This function plot all the data from .csv file, note that assume that the first colums is the time</p><p><strong>Arguments:</strong></p><ul><li><code>label_exp::String</code>: The label of the experiment.  </li><li><code>path_to_data::String</code>: The path to the .csv of data</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation </li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>save_plot=false</code> :Bool, save the plot or not</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia</li><li><code>overlay_plots =true</code> :Bool, if true it does one plot overlaying  all dataset curves</li><li><code>blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted,   if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed.</li></ul><p><strong>Output:</strong></p><ul><li>For this function the output are saved or displayed depending on the values of key arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L3-L43">source</a></section></article><h2 id="Fitting-one-a-.csv-file"><a class="docs-heading-anchor" href="#Fitting-one-a-.csv-file">Fitting one a .csv file</a><a id="Fitting-one-a-.csv-file-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-one-a-.csv-file" title="Permalink"></a></h2><h3 id="Log-Lin-fitting-2"><a class="docs-heading-anchor" href="#Log-Lin-fitting-2">Log-Lin fitting</a><a class="docs-heading-anchor-permalink" href="#Log-Lin-fitting-2" title="Permalink"></a></h3><p><a href="#JMAKi.fit_one_file_Log_Lin"><code>JMAKi.fit_one_file_Log_Lin</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_one_file_Log_Lin" href="#JMAKi.fit_one_file_Log_Lin"><code>JMAKi.fit_one_file_Log_Lin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_one_file_Log_Lin(
label_exp::String, 
path_to_data::String; 
path_to_annotation::Any = missing,
path_to_results=&quot;NA&quot;,
path_to_plot=&quot;NA&quot;,
display_plots=true,
save_plots=false, 
write_res=false,
type_of_smoothing=&quot;rolling_avg&quot;,
pt_avg=7,
pt_smoothing_derivative=7, 
pt_min_size_of_win=7, 
type_of_win=&quot;maximum&quot;, 
threshold_of_exp=0.9,
do_blank_subtraction=&quot;avg_blank&quot;,
avg_replicate=false, 
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01, 
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,
thr_lowess=0.05, 
verbose=false,
blank_value = 0.0,
blank_array = [0.0],)</code></pre><p>This function fits a logarithmic-linear model to a csv file. The function assumes that the first column is the time, see the documentation for example of the data format. It evaluate the specific growht rate, the with a statistical threshold it individuates a exponetial window and perform a-log lin fitting</p><p><strong>Arguments:</strong></p><ul><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>path_to_data::String</code>: Path to csv file containing the data    - <code>label_exp::String</code>: The label of the experiment.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation .</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: <code>&quot;NO&quot;</code> , <code>&quot;rolling avg&quot;</code> rolling average of the data, and <code>&quot;lowess&quot;</code>.</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>do_blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>do_blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed.</li><li><code>thr_negative=0.01</code>: FLoat: used only if <code>correct_negative == &quot;thr_correction&quot;</code> the data under this threshold will be changed to this value.</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li></ul><p><strong>Output:</strong></p><ul><li>a matrix with the following contents in each row : <code>[label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]</code></li><li>The plots of the log-linear fitting and of the dynamics of specific growth rate if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L182-L250">source</a></section></article><h3 id="ODE-fitting-2"><a class="docs-heading-anchor" href="#ODE-fitting-2">ODE fitting</a><a class="docs-heading-anchor-permalink" href="#ODE-fitting-2" title="Permalink"></a></h3><p><a href="#JMAKi.fit_file_ODE"><code>JMAKi.fit_file_ODE</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_file_ODE" href="#JMAKi.fit_file_ODE"><code>JMAKi.fit_file_ODE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_file_ODE(
label_exp::String, 
path_to_data::String, 
model::String,
lb_param::Vector{Float64},
ub_param::Vector{Float64};
path_to_annotation::Any = missing,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(),
path_to_results=&quot;NA&quot;,
path_to_plot=&quot;NA&quot;,
loss_type=&quot;RE&quot;, 
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
display_plots=true,
save_plots=false,
verbose=false, 
write_res=false, 
pt_avg=1, 
pt_smooth_derivative=7, 
do_blank_subtraction=&quot;avg_blank&quot;, 
avg_replicate=false,
correct_negative=&quot;thr_correction&quot;,
thr_negative=0.01,  
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
blank_value = 0.0,
blank_array = [0.0],)</code></pre><p>This function fits a ODE model to a csv file. The function assumes that the first column is the time, see the documentation for example of the data format. It evaluate the specific growht rate, the with a statistical threshold it individuates a exponetial window and perform a-log lin fitting</p><p><strong>Arguments:</strong></p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>model::String</code>:String of the ODE to be fitted. See the documentation for the complete list.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator = BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation .</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: <code>&quot;NO&quot;</code> , <code>&quot;rolling avg&quot;</code> rolling average of the data, and <code>&quot;lowess&quot;</code>.</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>do_blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>do_blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li></ul><p><strong>Output:</strong></p><ul><li>an matrix with the following contents for each row :<code>[] &quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; are the parameter of the selected ODE as in the documentation.</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L433-L513">source</a></section></article><p><a href="#JMAKi.fit_file_custom_ODE"><code>JMAKi.fit_file_custom_ODE</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_file_custom_ODE" href="#JMAKi.fit_file_custom_ODE"><code>JMAKi.fit_file_custom_ODE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_file_custom_ODE(
label_exp::String, 
path_to_data::String,
model::Any, 
lb_param::Vector{Float64},
ub_param::Vector{Float64},
n_equation::Int;
path_to_annotation::Any = missing,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(),
path_to_results=&quot;NA&quot;,
path_to_plot=&quot;NA&quot;, 
loss_type=&quot;RE&quot;,
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
display_plots=true,
save_plots=false,
verbose=false, 
write_res=false,
pt_avg=1,
pt_smooth_derivative=7,
do_blank_subtraction=&quot;avg_blank&quot;,
avg_replicate=false,
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01,  
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
blank_value = 0.0,
blank_array = [0.0],)</code></pre><p>This function is designed for fitting an ordinary differential equation (ODE) model to a dataset in a csv file. . It utilizes a customizable ODE model, see documentation on how declare the model</p><p><strong>Arguments:</strong></p><ul><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>path_to_data::String</code>: Path to csv file containing the data</li><li><code>model::Any</code>: Function of the ODE to be fitted. See the documentation for examples.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li><li><code>n_equation::Int</code>:  number ode in the system</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator = BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation .</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: <code>&quot;NO&quot;</code> , <code>&quot;rolling avg&quot;</code> rolling average of the data, and <code>&quot;lowess&quot;</code>.</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li></ul><p><strong>Output:</strong></p><ul><li>a matrix with the following contents for each row : <code>[ &quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L704-L792">source</a></section></article><p><a href="#JMAKi.ODE_model_selection_file"><code>JMAKi.ODE_model_selection_file</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.ODE_model_selection_file" href="#JMAKi.ODE_model_selection_file"><code>JMAKi.ODE_model_selection_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ODE_model_selection_file(
label_exp::String, 
path_to_data::String, 
models_list::Vector{String}, 
lb_param_array::Any, 
ub_param_array::Any; 
path_to_annotation::Any = missing,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
path_to_results=&quot;NA&quot;,
path_to_plot=&quot;NA&quot;, 
loss_type=&quot;L2&quot;, 
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
display_plot_best_model=false, 
save_plot_best_model=false,
beta_penality=2.0, 
verbose=false,
write_res=false,
pt_avg=1,
pt_smooth_derivative=7, 
do_blank_subtraction=&quot;avg_blank&quot;, 
avg_replicate=false,
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01,  
multiple_scattering_correction=false,
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
correction_AIC=true,
blank_value = 0.0,
blank_array = [0.0],)</code></pre><p>This function performs model selection  of ODE for a full csv file.</p><p><strong>Arguments:</strong></p><ul><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>path_to_data::String</code>: Path to csv file containing the data    </li><li><code>models_list::Vector{String}</code>: list of ODE model used</li><li><code>models_list::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>lb_param_array::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>ub_param_array::Any</code>: Upper bounds</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator = BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation .</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: <code>&quot;NO&quot;</code> , <code>&quot;rolling avg&quot;</code> rolling average of the data, and <code>&quot;lowess&quot;</code>.</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li></ul><p><strong>Output:</strong></p><ul><li>an matrix with the following contents for each row : <code>[ &quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L977-L1065">source</a></section></article><h3 id="NL-fitting"><a class="docs-heading-anchor" href="#NL-fitting">NL fitting</a><a id="NL-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#NL-fitting" title="Permalink"></a></h3><p><a href="#JMAKi.fit_NL_model_file"><code>JMAKi.fit_NL_model_file</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model_file" href="#JMAKi.fit_NL_model_file"><code>JMAKi.fit_NL_model_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_NL_model_file(
label_exp::String,
path_to_data::String, 
model::Any,
lb_param::Vector{Float64},
ub_param::Vector{Float64};
path_to_annotation::Any = missing,
u0=lb_param .+ (ub_param .- lb_param) ./ 2,
method_of_fitting=&quot;MCMC&quot;,
nrep=100,
errors_estimation=false,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
path_to_results=&quot;NA&quot;, 
path_to_plot=&quot;NA&quot;, 
loss_type=&quot;RE&quot;, 
smoothing=false,
type_of_smoothing=&quot;lowess&quot;,
display_plots=true,
save_plots=false,
verbose=false, 
write_res=false, 
pt_avg=1, 
pt_smooth_derivative=7, 
do_blank_subtraction=&quot;avg_blank&quot;, 
avg_replicate=false, 
correct_negative=&quot;thr_correction&quot;,
thr_negative=0.01,  
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
penality_CI=8.0,
size_bootstrap=0.7,
blank_value = 0.0,
blank_array = [0.0],
)</code></pre><p>This function performs NL model selection of one NL model for a full csv file</p><p><strong>Arguments</strong></p><ul><li><code>label_exp::String</code>,  label of the experiment.</li><li><code>path_to_data::String</code>. path to the csv data frame. See documentation for formatting it.</li><li><code>model::Any</code>:  functions or strings (for harcoded NL model) of the NL models</li><li><code>lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plots=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64, keyword argument of lowess smoothing</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_model_file(...)</code>:</strong></p><ul><li>a matrix with the following contents for each row : <code>[ &quot;label of exp&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using model&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_file.jl#L2-L91">source</a></section></article><p><a href="#JMAKi.fit_NL_model_selection_file"><code>JMAKi.fit_NL_model_selection_file</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_model_selection_file" href="#JMAKi.fit_NL_model_selection_file"><code>JMAKi.fit_NL_model_selection_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function fit_NL_model_selection_file(
label_exp::String, 
path_to_data::String, 
list_model_function::Any,
list_lb_param::Vector{Float64}, 
list_ub_param::Vector{Float64}; 
path_to_annotation::Any = missing,
method_of_fitting=&quot;MCMC&quot;,
nrep=100,
list_u0=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
path_to_results=&quot;NA&quot;, 
path_to_plot=&quot;NA&quot;, 
loss_type=&quot;RE&quot;,
smoothing=false, 
type_of_smoothing=&quot;lowess&quot;,
display_plots=true,
save_plots=false,
verbose=false, 
write_res=false,
pt_avg=1,
pt_smooth_derivative=7, 
do_blank_subtraction=&quot;avg_blank&quot;, 
avg_replicate=false, 
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01,  
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;, 
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
thr_lowess=0.05,
beta_param=2.0,
penality_CI=8.0,
size_bootstrap=0.7,
correction_AIC=true,
blank_value = 0.0,
blank_array = [0.0],
)</code></pre><p>This function performs NL model selection of an array of NL models, it uses AIC or AICc depending on user inputs. This is done for a full .csv file.</p><p><strong>Arguments</strong></p><ul><li><code>label_exp::String</code>,  label of the experiment.</li><li><code>path_to_data::String</code>. path to the csv data frame. See documentation for formatting it.</li><li><code>list_model_function::Any</code>: Array containing functions or strings of the NL models</li><li><code>list_lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plot_best_model=false</code> :Bool, save the plot or not.</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowess smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=8.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li></ul><p><strong>Output (if <code>results_NL_fit =NL_model_selection(...)</code>:</strong></p><ul><li>a matrix with the following contents for each row : <code>[ &quot;label of exp&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using model&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_file.jl#L477-L569">source</a></section></article><h3 id="Segmented-fitting-2"><a class="docs-heading-anchor" href="#Segmented-fitting-2">Segmented fitting</a><a class="docs-heading-anchor-permalink" href="#Segmented-fitting-2" title="Permalink"></a></h3><p><a href="#JMAKi.segmentation_ODE_file"><code>JMAKi.segmentation_ODE_file</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.fit_NL_segmentation_file" href="#JMAKi.fit_NL_segmentation_file"><code>JMAKi.fit_NL_segmentation_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_NL_segmentation_file(
label_exp::String, 
path_to_data::String, 
list_model_function::Any,
list_lb_param::Vector{Vector{Float64}}, 
list_ub_param::Vector{Vector{Float64}}, 
n_change_points::Int;
path_to_annotation::Any = missing,
method_of_fitting=&quot;MCMC&quot;,
nrep=100,
list_u0=lb_param .+ (ub_param .- lb_param) ./ 2,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
path_to_results=&quot;NA&quot;,
path_to_plot=&quot;NA&quot;, 
loss_type=&quot;RE&quot;, 
smoothing=false, 
type_of_smoothing=&quot;lowess&quot;,
display_plots=true,
save_plots=false,
verbose=false, 
write_res=false,
pt_avg=1, 
pt_smooth_derivative=7, 
do_blank_subtraction=&quot;avg_blank&quot;, 
avg_replicate=false,
correct_negative=&quot;thr_correction&quot;, 
thr_negative=0.01,  
multiple_scattering_correction=false, 
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
size_bootstrap=0.7,
thr_lowess=0.05,
detect_number_cpd=true,
type_of_detection=&quot;sliding_win&quot;,
type_of_curve=&quot;original&quot;,
fixed_cpd=false,
penality_CI=8.0,
beta_smoothing_ms=2.0,
win_size=7,
n_bins=40,
correction_AIC=true,
blank_value = 0.0,
blank_array = [0.0],
)</code></pre><p>This function performs NL model selection  on a segmented time series, it uses AIC or AICc depending on user inputs. This fuction works on an entire csv file.</p><p><strong>Arguments</strong></p><ul><li><code>label_exp::String</code>,  label of the experiment./</li><li><code>path_to_data::String</code>. path to the csv data frame. See documentation for formatting it.</li><li><code>list_model_function::Any</code>: Array containing functions or strings of the NL models</li><li><code>list_lb_param::Any</code>:Array of Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>:Array of Upper bounds for the parameters (compatible with the models).</li><li><code>n_max_change_points::Int</code>: Number of change point used, the results will have different number of cp depending on the values of key argument &#39;type<em>of</em>detection&#39; and &#39;fixed_cpd&#39;</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>method_of_fitting=&quot;MCMC&quot;</code>: String, how perform the NL fit. Options &quot;MCMC&quot;,&quot;Bootstrap&quot;,&quot;Normal&quot;, and &quot;Morris_sensitivity&quot;</li><li><code>nrep=100</code>. Number of MCMC steps.</li><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>save_plots=false</code> :Bool, save the plot or not.</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: &quot;NO&quot; , &quot;rolling avg&quot; rolling average of the data, and &quot;lowess&quot;.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowess smoothing</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>penality_CI=2.0</code>, used only in segementation to force the optimization to respect continuty on bonduar</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_param=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li><code>size_bootstrap=0.7</code>: Float, the fraction of data used each Bootstrap run. Used only if method is &quot;Bootstrap&quot;</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li>&#39;type<em>of</em>detection=&quot;slinding<em>win&quot;&#39;: String, algorithm of cpd to use. Options &#39;&quot;slinding</em>win&quot;&#39; use a slinding window approach, &#39;&quot;lsdd&quot;&#39; uses least square density difference (LSDD) from ChangePointDetection.jl </li><li>&#39;type<em>of</em>curve=&quot;original&quot;&#39;: String, on which curve is performed the change point detection algorithm. If &#39;&quot;original&quot;&#39; it use the original time series. With &#39;&quot;deriv&quot;&#39; it use the specific growth rate time series to perform the cdp.</li><li><code>method_peaks_detection=&quot;peaks_prominence&quot;</code>: How the peak detection is performed on the dissimilarity curve.  <code>&quot;peaks_prominence&quot;</code> orders the peaks by prominence. <code>thr_scan</code> uses a threshold to choose the peaks</li><li><code>n_bins=40</code>: Int, used if <code>method_peaks_detection=&quot;thr_scan&quot;</code> number of bins used to generate the threshold that has n<em>change</em>points peaks</li><li>&#39;detect<em>number</em>cpd=true&#39;: Bool, if equal to true all the possible combination of lenght 1,2,...,n<em>change</em>points are tested and the best for AICc is returned.</li><li>&#39;fixed<em>cpd=false&#39;: Bool If  true it returns the fitting using top n</em>change_points.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li>&#39;win_size=14&#39;: Int, size of the windows used by the cdp algorithms</li></ul><p><strong>Output (if <code>results_NL_fit =fit_NL_segmentation_file(...)</code>:</strong></p><ul><li>an matrix with the following contents for each row : <code>[ &quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using model&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot; &quot;segment number&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/NL_fit_one_file.jl#L769-L872">source</a></section></article><p><a href="#JMAKi.fit_NL_segmentation_file"><code>JMAKi.fit_NL_segmentation_file</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.segmentation_ODE_file" href="#JMAKi.segmentation_ODE_file"><code>JMAKi.segmentation_ODE_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segmentation_ODE_file(
label_exp::String, 
path_to_data::String, 
list_of_models::Vector{String},  
lb_param_array::Any, 
ub_param_array::Any,
n_max_change_points::Int;
path_to_annotation::Any = missing,
detect_number_cpd=true,
fixed_cpd=false,
optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), 
integrator=Tsit5(), 
type_of_loss=&quot;L2&quot;, 
type_of_detection=&quot;sliding_win&quot;,
type_of_curve=&quot;original&quot;,
do_blank_subtraction=&quot;avg_blank&quot;,
correct_negative=&quot;thr_correction&quot;,
thr_negative=0.01,
pt_avg=1,
smoothing=true, 
save_plots=false, 
display_plots=false, 
path_to_plot=&quot;NA&quot;,
path_to_results=&quot;NA&quot;,
win_size=7,
pt_smooth_derivative=0,
penality_parameter=2.0,
avg_replicate=false,
multiple_scattering_correction=&quot;false&quot;,
method_multiple_scattering_correction=&quot;interpolation&quot;,
calibration_OD_curve=&quot;NA&quot;,  
write_res=false,
save_all_model=false,
method_peaks_detection=&quot;peaks_prominence&quot;,
n_bins=40,
PopulationSize=300,
maxiters=2000000,
abstol=0.00001,
type_of_smoothing=&quot;lowess&quot;,
thr_lowess=0.05,
verbose=false,
correction_AIC=true,
blank_value = 0.0,
blank_array = [0.0],)</code></pre><p>This function performs model selection for ordinary differential equation (ODE) models while segmenting the time series in various part using change points detection algorithm, for a full csv file.</p><p><strong>Arguments:</strong></p><ul><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>path_to_data::String</code>: Path to csv file containing the data</li><li><code>list_of_models::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>list_lb_param::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>: Upper bounds for the parameters (compatible with the models).</li><li><code>n_max_change_points::Int</code>: Number of change point used, the results will have different number of cp depending on the values of key argument &#39;type<em>of</em>detection&#39; and &#39;fixed_cpd&#39;</li></ul><p><strong>Key Arguments:</strong></p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>:Vector{Float64}, Initial guess for the model parameters.</li><li>`integrator =Tsit5()&#39; sciML integrator. If using piecewise model please use  &#39;KenCarp4(autodiff=true)&#39;.</li><li><code>optmizator = BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>average_replicate=false</code> Bool, perform or not the average of replicates. Works only if an annotation path is provided</li><li><code>path_to_annotation::Any = missing</code>: The path to the .csv of annotation .</li><li><code>path_to_plot= &quot;NA&quot;</code>:String, path to save the plots.</li><li><code>write_res=false</code>: Bool, write the results in path<em>to</em>results folder.</li><li><code>path_to_results= &quot;NA&quot;</code>:String, path to the folder where save the results.</li><li><code>save_plot=false</code> :Bool, save the plot or not.</li><li><code>display_plots=true</code>:Bool,  Whether or not diplay the plot in julia.</li><li><code>type_of_smoothing=&quot;rolling_avg&quot;</code>: String, How to smooth the data, options: <code>&quot;NO&quot;</code> , <code>&quot;rolling avg&quot;</code> rolling average of the data, and <code>&quot;lowess&quot;</code>.</li><li><code>pt_avg=7</code>:Int, The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:Int,  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>:Int, The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>:String, How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.</li><li><code>multiple_scattering_correction=false</code>:Bool, Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: String, The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>multiple_scattering_correction=false</code>: Bool, if true uses the given calibration curve to correct the data for muliple scattering.</li><li><code>method_multiple_scattering_correction=&quot;interpolation&quot;</code>: String, How perform the inference of multiple scattering curve, options: &quot;interpolation&quot; or   &quot;exp_fit&quot; it uses an exponential fit from &quot;Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications&quot;</li><li><code>thr_lowess=0.05</code>: Float64 keyword argument of lowees smoothing.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters=2000000</code>: stop criterion, the optimization is stopped when the number of iterations is bigger than <code>maxiters</code></li><li><code>abstol = 0.00001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li><li><code>correct_negative=&quot;thr_correction&quot;</code>: # if &quot;thr<em>correction&quot; it put a thr on the minimum value of the data with blank subracted, if &quot;blank</em>correction&quot; uses blank distrib to impute negative values.</li><li><code>blank_value = 0.0</code>: used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as average value of the blank.</li><li><code>blank_array = [0.0]</code>:used only if <code>path_to_annotation = missing</code>and <code>blank_subtraction != &quot;NO &quot;</code>. It is used as array of the blanks values.</li><li><code>correct_negative=&quot;thr_correction&quot;</code>  ;: String, How to treat negative values after blank subtraction. If <code>&quot;thr_correction&quot;</code> it put a thr on the minimum value of the data with blank subracted, if <code>&quot;blank_correction&quot;</code> uses blank distribution to impute negative values, if <code>&quot;remove&quot;</code> the values are just removed..</li><li><code>do_blank_subtraction=&quot;NO&quot;</code>: String, how perform the blank subtration, options &quot;NO&quot;,&quot;avg<em>subtraction&quot; (subtration of average value of blanks) and &quot;time</em>avg&quot; (subtration of  time average value of blanks).  </li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li><li>&#39;type<em>of</em>detection=&quot;slinding<em>win&quot;&#39;: String, algorithm of cpd to use. Options &#39;&quot;slinding</em>win&quot;&#39; use a slinding window approach, &#39;&quot;lsdd&quot;&#39; uses least square density difference (LSDD) from ChangePointDetection.jl </li><li>&#39;type<em>of</em>curve=&quot;original&quot;&#39;: String, on which curve is performed the change point detection algorithm. If &#39;&quot;original&quot;&#39; it use the original time series. With &#39;&quot;deriv&quot;&#39; it use the specific growth rate time series to perform the cdp.</li><li><code>method_peaks_detection=&quot;peaks_prominence&quot;</code>: How the peak detection is performed on the dissimilarity curve.  <code>&quot;peaks_prominence&quot;</code> orders the peaks by prominence. <code>thr_scan</code> uses a threshold to choose the peaks</li><li><code>n_bins=40</code>: Int, used if <code>method_peaks_detection=&quot;thr_scan&quot;</code> number of bins used to generate the threshold that has n<em>change</em>points peaks</li><li>&#39;detect<em>number</em>cpd=true&#39;: Bool, if equal to true all the possible combination of lenght 1,2,...,n<em>change</em>points are tested and the best for AICc is returned.</li><li>&#39;fixed<em>cpd=false&#39;: Bool If  true it returns the fitting using top n</em>change_points.</li><li>&#39;win_size=14&#39;: Int, size of the windows used by the cdo algorithms</li><li>&#39;path<em>to</em>results=&quot;NA&quot;&#39;:String, where to save the results.</li><li>&#39;save<em>all</em>model=false&#39;: Bool, if true all the tested model are saved.</li><li><code>correction_AIC=true</code>: Bool, do finite samples correction of AIC.</li><li><code>beta_penality=2.0</code> penality  parameters for AIC (or AICc) evaluation.</li></ul><p><strong>Output:</strong></p><ul><li>an matrix with the following contents for each row : <code>[ &quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot; &quot;segment number&quot;]</code> where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param_n&quot; &#39; .</li><li>The plots of the fit if <code>save_plot=true</code> or <code>display_plots=true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/Fit_one_file_functions.jl#L1265-L1376">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><h3 id="ODE-simulations"><a class="docs-heading-anchor" href="#ODE-simulations">ODE simulations</a><a id="ODE-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-simulations" title="Permalink"></a></h3><p><a href="#JMAKi.ODE_sim"><code>JMAKi.ODE_sim</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.ODE_sim" href="#JMAKi.ODE_sim"><code>JMAKi.ODE_sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ODE_sim(
model::String, 
n_start::Vector{Float64}, 
tstart::Float64, 
tmax::Float64,
delta_t::Float64, 
param_of_ode::Vector{Float64};
integrator=KenCarp4(),
)</code></pre><p>This function performs an ODE simulation of a model</p><p><strong>Arguments:</strong></p><ul><li><code>model::String</code>: The model to simulate. For the possible options please check the documentation.</li><li><code>n_start::Vector{Float64}</code>: The starting conditions.</li><li><code>tstart::Float64</code>: The start time of the simulation.</li><li><code>tmax::Float64</code>: The final time of the simulation.</li><li><code>delta_t::Float64</code>: The time step of the output.</li><li><code>param_of_ode::Vector{Float64}</code>: The parameters of the ODE model.</li></ul><p><strong>Key argument:</strong></p><ul><li><code>integrator=KenCarp4()</code>: The chosen solver from the SciML ecosystem for ODE integration, default KenCarp4 algorithm. </li></ul><p><strong>Output:</strong></p><ul><li>it returns a standard SciML output (i.e., if <code>sim =ODE_sim(...)</code>, then <code>sim.t</code> is the array of times and <code>sim.u</code> is the array of the simulation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/functions.jl#L199-L228">source</a></section></article><h3 id="Stochastic-simulations"><a class="docs-heading-anchor" href="#Stochastic-simulations">Stochastic simulations</a><a id="Stochastic-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-simulations" title="Permalink"></a></h3><p><a href="#JMAKi.stochastic_sim"><code>JMAKi.stochastic_sim</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.stochastic_sim" href="#JMAKi.stochastic_sim"><code>JMAKi.stochastic_sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stochastic_sim(
model::String,
n_start::Int, 
n_mol_start::Float64, 
tstart::Float64, 
tmax::Float64, 
delta_t::Float64, 
k_1_val::Float64,
k_2_val::Float64, 
alpha_val::Float64, 
lambda::Float64, 
n_mol_per_birth::Float64,
volume::Float64,
)</code></pre><p>This function performs a stochastic simulation of a model, considering cell growth and nutrient consumption over time.</p><p><strong>Arguments:</strong></p><ul><li><code>model::String</code>: The model to simulate. Possible options &quot;Monod&quot;,&quot;Haldane&quot;,&quot;Blackman&quot;,&quot;Tessier&quot;,&quot;Moser&quot;,&quot;Aiba-Edwards&quot;, and &quot;Verhulst&quot;</li><li><code>n_start::Int</code>: The number of starting cells.</li><li><code>n_mol_start::Float64</code>: The starting concentration of the limiting nutrient.</li><li><code>tstart::Float64</code>: The start time of the simulation.</li><li><code>tmax::Float64</code>: The final time of the simulation.</li><li><code>delta_t::Float64</code>: The time step for the Poisson approximation.</li><li><code>k_1_val::Float64</code>: The value of parameter k1.</li><li><code>k_2_val::Float64</code>: The value of the Monod constant.</li><li><code>alpha_val::Float64</code>: The maximum possible growth rate.</li><li><code>lambda::Float64</code>: The lag time, simulated as a zero growht time span at the start</li><li><code>n_mol_per_birth::Float64</code>: The nutrient consumed per division (mass).</li><li><code>volume::Float64</code>: The volume.</li></ul><p><strong>Output (if <code>sim =stochastic_sim(...)</code>):</strong></p><ul><li><code>sim[1]</code>: array of the number of individuals in the population.</li><li><code>sim[2]</code>: array of the number of biomass equivalent mass of the limiting nutrient concentration.</li><li><code>sim[3]</code>: array of the times of the simulation. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/functions.jl#L270-L310">source</a></section></article><h2 id="Various"><a class="docs-heading-anchor" href="#Various">Various</a><a id="Various-1"></a><a class="docs-heading-anchor-permalink" href="#Various" title="Permalink"></a></h2><p><a href="#JMAKi.specific_gr_evaluation"><code>JMAKi.specific_gr_evaluation</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JMAKi.specific_gr_evaluation" href="#JMAKi.specific_gr_evaluation"><code>JMAKi.specific_gr_evaluation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specific_gr_evaluation(data_smooted::Any, 
pt_smoothing_derivative::Int)</code></pre><p>Function that evalauates specific gr evaluation with slinding window log-lin fitting</p><p><strong>Arguments:</strong></p><ul><li>&#39;data<em>smooted&#39;:  matrix of data 2xn</em>time points, it is a single curve.</li><li>&#39;pt<em>smoothing</em>derivative&#39;: Int size of the win, if &lt;2 the the numerical derivative of (log) data is evaluate with interpolation algorithm</li></ul><p><strong>Output:</strong></p><ul><li>&#39;specific_gr&#39; an array with the specific growth rate </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ang-one/JMAKi.jl/blob/5be17dce0f418a3bf96cc10c6044049195a72407/src/functions.jl#L26-L41">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../05_examples/">« Examples and Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 15 May 2024 16:03">Wednesday 15 May 2024</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
