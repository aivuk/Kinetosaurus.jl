<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The main functions of JMAKi · JMAKi Documentation</title><meta name="title" content="The main functions of JMAKi · JMAKi Documentation"/><meta property="og:title" content="The main functions of JMAKi · JMAKi Documentation"/><meta property="twitter:title" content="The main functions of JMAKi · JMAKi Documentation"/><meta name="description" content="Documentation for JMAKi Documentation."/><meta property="og:description" content="Documentation for JMAKi Documentation."/><meta property="twitter:description" content="Documentation for JMAKi Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="JMAKi Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">JMAKi Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">JMAKi - Julia Model-based Analyses of microbial Kinetics</a></li><li><a class="tocitem" href="../01_install/">Installation &amp; requirements</a></li><li><a class="tocitem" href="../02_data/">Data and annotation formatting</a></li><li class="is-active"><a class="tocitem" href>The main functions of JMAKi</a><ul class="internal"><li><a class="tocitem" href="#Simulate-ODE"><span>Simulate ODE</span></a></li><li><a class="tocitem" href="#Stochastic-simulation"><span>Stochastic simulation</span></a></li><li><a class="tocitem" href="#Plotting-a-dataset-from-file"><span>Plotting a dataset from file</span></a></li><li><a class="tocitem" href="#Specific-growth-rate-evaluation"><span>Specific growth rate evaluation</span></a></li><li><a class="tocitem" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-well"><span>Fitting growth rate with log-lin fitting for one well</span></a></li><li><a class="tocitem" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-file"><span>Fitting growth rate with log-lin fitting for one file</span></a></li><li><a class="tocitem" href="#Fitting-ODE-function-for-one-well"><span>Fitting ODE function for one well</span></a></li><li><a class="tocitem" href="#Fitting-ODE-function-for-one-file"><span>Fitting ODE function for one file</span></a></li><li><a class="tocitem" href="#Fitting-custom-ODE-function-for-one-well"><span>Fitting custom ODE function for one well</span></a></li><li><a class="tocitem" href="#Sensitivity-analysis"><span>Sensitivity analysis</span></a></li><li><a class="tocitem" href="#Model-selection"><span>Model selection</span></a></li><li><a class="tocitem" href="#Change-point-detection"><span>Change point detection</span></a></li><li><a class="tocitem" href="#Fitting-segmented-ODE-with-fixed-change-point-number"><span>Fitting segmented ODE with fixed change-point number</span></a></li><li><a class="tocitem" href="#Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points"><span>Fitting segmented ODE with direct search for a maximum number of change-points</span></a></li></ul></li><li><a class="tocitem" href="../04_math/">The mathematical models</a></li><li><a class="tocitem" href="../05_examples/">Examples and Tutorial</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The main functions of JMAKi</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The main functions of JMAKi</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ang-one/JMAKi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ang-one/JMAKi.jl/blob/main/docs/src/03_main/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">The main functions of JMAKi</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ol><li><a href="#simulating-ODE">Simulate ODE</a></li><li><a href="#simulating-stochastic">Stochastic simulation</a></li><li><a href="#plot-file">Plotting a dataset from file</a></li><li><a href="#Specific_growth_rate_evaluation">Specific growth rate evaluation</a></li><li><a href="#log-lin-one-well">Fitting growth rate with log-lin fitting for one well</a></li><li><a href="#log-lin-file">Fitting growth rate with log-lin fitting for one file</a></li><li><a href="#ODE-one-well">Fitting ODE function for one well</a></li><li><a href="#ODE-file">Fitting ODE function for one file</a></li><li><a href="#custom-ODE">Fitting custom ODE function</a></li><li><a href="#Sensitivity-analysis">Sensitivity analysis</a></li><li><a href="#Model-selection">Model selection</a></li><li><a href="#cdp">Change points detection</a></li><li><a href="#cdp-fixed">Fitting segmented ODE with fixed change-point number</a></li><li><a href="#cdp-search">Fitting segmented ODE with direct search for a maximum number of change-points</a></li></ol><p>&lt;a name=&quot;simulating-ODE&quot;&gt;&lt;/a&gt;</p><h2 id="Simulate-ODE"><a class="docs-heading-anchor" href="#Simulate-ODE">Simulate ODE</a><a id="Simulate-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-ODE" title="Permalink"></a></h2><pre><code class="language-julia hljs">
   ODE_sim(model::String, 
    n_start::Vector{Float64}, 
    tstart::Float64, 
    tmax::Float64, 
    delta_t::Float64, 
    param_of_ode::Vector{Float64}; 
    integrator = KenCarp4() 
)</code></pre><p>This function performs an ODE simulation of a model, considering the initial conditions, time range, and integration parameters.</p><p>Arguments:</p><ul><li><p><code>model::String</code>: The model to simulate.</p></li><li><p><code>n_start::Vector{Float64}</code>: The starting conditions.</p></li><li><p><code>tstart::Float64</code>: The start time of the simulation.</p></li><li><p><code>tmax::Float64</code>: The final time of the simulation.</p></li><li><p><code>delta_t::Float64</code>: The time step of the output.</p></li><li><p><code>param_of_ode::Vector{Float64}</code>: The parameters of the ODE model.</p></li></ul><p>Key argument:</p><ul><li><code>integrator=KenCarp4()</code>: The chosen solver from the SciML ecosystem for ODE integration, default KenCarp4 algorithm.</li></ul><p>Output:</p><ul><li>it returns a standard SciML output (i.e., if <code>sim =ODE_sim(...)</code>, then <code>sim.t</code> is the array of times and <code>sim.u</code> is the array of the simulation)</li></ul><p>&lt;a name=&quot;simulating-stochastic&quot;&gt;&lt;/a&gt;</p><h2 id="Stochastic-simulation"><a class="docs-heading-anchor" href="#Stochastic-simulation">Stochastic simulation</a><a id="Stochastic-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-simulation" title="Permalink"></a></h2><pre><code class="language-julia hljs">    stochastic_sim(model::String,
         n_start::Int,
         n_mol_start::Float64,
        tstart::Float64,
        tmax::Float64,
        delta_t::Float64,
        k_1_val::Float64,
        k_2_val::Float64,
        alpha_val::Float64,
        lambda::Float64,
        n_mol_per_birth::Float64,
        volume::Float64)</code></pre><p>This function performs a stochastic simulation of a model, considering cell growth and nutrient consumption over time.</p><p>Arguments:</p><ul><li><code>model::String</code>: The model to simulate. PUT the options</li><li><code>n_start::Int</code>: The number of starting cells.</li><li><code>n_mol_start::Float64</code>: The starting concentration of the limiting nutrient.</li><li><code>tstart::Float64</code>: The start time of the simulation.</li><li><code>tmax::Float64</code>: The final time of the simulation.</li><li><code>delta_t::Float64</code>: The time step for the Poisson approximation.</li><li><code>k_1_val::Float64</code>: The value of parameter k1.</li><li><code>k_2_val::Float64</code>: The value of the Monod constant.</li><li><code>alpha_val::Float64</code>: The maximum possible growth rate.</li><li><code>lambda::Float64</code>: The lag time.</li><li><code>n_mol_per_birth::Float64</code>: The nutrient consumed per division (mass).</li><li><code>volume::Float64</code>: The volume.</li></ul><p>Output (if <code>sim =stochastic_sim(...)</code>):</p><ul><li><code>sim[1]</code>: array of the number of individuals in the population.</li><li><code>sim[2]</code>: array of the number of biomass equivalent mass of the limiting nutrient concentration.</li><li><code>sim[3]</code>: array of the times of the simulation. </li></ul><p>&lt;a name=&quot;plot-file&quot;&gt;&lt;/a&gt;</p><h2 id="Plotting-a-dataset-from-file"><a class="docs-heading-anchor" href="#Plotting-a-dataset-from-file">Plotting a dataset from file</a><a id="Plotting-a-dataset-from-file-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-a-dataset-from-file" title="Permalink"></a></h2><pre><code class="language-julia hljs">plot_data( label_exp::String, 
    path_to_data::String, 
    path_to_annotation::String;
    path_to_plot=&quot;NA&quot;, 
    display_plots=true ,
    save_plot=false, 
    overlay_plots=true, 
    blank_subtraction=&quot;NO&quot;, 
    average_replicate=false, 
    correct_negative=&quot;thr_correction&quot;, 
    thr_negative=0.01,
    )
    </code></pre><p>This function plot all the data from .csv file Arguments:</p><ul><li><code>path_to_data::String</code>: The path to the .csv of data</li><li><code>path_to_annotation::String</code>: The path to the .csv of annotation </li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li></ul><p>Key Arguments:</p><ul><li><code>path_to_plot= &quot;NA&quot;</code>: Path to save the plots.</li><li><code>save_plot=false</code> : save the plot or not</li><li><code>display_plots=true</code>: Whether or not diplay the plot in julia</li><li><code>overlay_plots =true</code> : true on plot for all dataset false one plot per well</li><li><code>verbose=false</code>: Whether to enable verbose output.</li><li><code>pt_avg=7</code>: Number of points to use for smoothing average.</li><li><code>blank_subtraction=&quot;NO&quot;</code>: </li><li><code>average_replicate=false</code></li><li><code>multiple_scattering_correction=false</code>: Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li></ul><p>Output:</p><ul><li>For this function the output are saved or displayed depending on the values of key arguments.</li></ul><p>&lt;a name=&quot;Specific-growth-rate-evaluation&quot;&gt;&lt;/a&gt;</p><h2 id="Specific-growth-rate-evaluation"><a class="docs-heading-anchor" href="#Specific-growth-rate-evaluation">Specific growth rate evaluation</a><a id="Specific-growth-rate-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-growth-rate-evaluation" title="Permalink"></a></h2><pre><code class="nohighlight hljs">specific_gr_evaluation(data_smooted::Matrix{Float64},
     pt_smoothing_derivative::Int)</code></pre><p>This function evaluate the specific growth rate of a growth curve</p><p>Arguments:</p><ul><li><code>data_smooted::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see <a href="#data">data formatting</a>.</li><li><code>pt_smoothing_derivative::Int</code> Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li></ul><p>&lt;a name=&quot;log-lin-one-well&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-growth-rate-with-log-lin-fitting-for-one-well"><a class="docs-heading-anchor" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-well">Fitting growth rate with log-lin fitting for one well</a><a id="Fitting-growth-rate-with-log-lin-fitting-for-one-well-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-well" title="Permalink"></a></h2><pre><code class="language-julia hljs"> fitting_one_well_Log_Lin(data::Matrix{Float64}, 
    name_well::String, 
    label_exp::String; 
    do_plot=false,
    path_to_plot=&quot;NA&quot;, 
    type_of_smoothing=&quot;rolling_avg&quot;,
    pt_avg=7, 
    pt_smoothing_derivative=7, 
    pt_min_size_of_win=7, 
    type_of_win=&quot;maximum&quot;, 
    threshold_of_exp=0.9, 
    multiple_scattering_correction=false,
    calibration_OD_curve =&quot;NA&quot; 
    )</code></pre><p>This function fits a logarithmic-linear model to a single well&#39;s data and performs analysis such as plotting and error calculation. Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see <a href="#data">data formatting</a>.</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li></ul><p>Key Arguments:</p><ul><li><code>do_plot=true</code>: Whether to generate and save plots.</li><li><code>path_to_plot=&quot;NA&quot;</code>: The path to save the plots, used only if <code>do_plot=true</code>.</li><li><code>pt_avg=7</code>: The number of points to do rolling average smoothing.</li><li><code>pt_smoothing_derivative=7</code>:  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>: The minimum size of the exponential windows in the number of smoothed points.</li><li><code>type_of_win=&quot;maximum&quot;</code>: How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>: The threshold of the growth rate in quantile to define the exponential windows.</li><li><code>multiple_scattering_correction=false</code>: Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li></ul><p>Output:</p><ul><li>an array with the following contents:</li></ul><p><code>results_lin_log_fit = [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]</code></p><ul><li>The plots of the log-linear fitting and of the dynamics of specific growth rate if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;log-lin-file&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-growth-rate-with-log-lin-fitting-for-one-file"><a class="docs-heading-anchor" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-file">Fitting growth rate with log-lin fitting for one file</a><a id="Fitting-growth-rate-with-log-lin-fitting-for-one-file-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-growth-rate-with-log-lin-fitting-for-one-file" title="Permalink"></a></h2><pre><code class="language-julia hljs">    fit_one_file_Log_Lin(
    label_exp::String, 
    path_to_data::String,
    path_to_annotation::String;
    path_to_results = &quot;NA&quot;,
    path_to_plot= &quot;NA&quot;,
    do_plot=false, 
    verbose=false,
    write_res=false, 
    type_of_smoothing=&quot;rolling_avg&quot;, 
    pt_avg=7,
    pt_smoothing_derivative=7, 
    pt_min_size_of_win=7, 
    type_of_win=&quot;maximum&quot;, 
    threshold_of_exp=0.9, 
    blank_subtraction=&quot;avg_blank&quot;, 
    fit_replicate=false, 
    correct_negative=&quot;thr_correction&quot;,
    thr_negative=0.01, 
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot; 
    )</code></pre><p>This function fits a logarithmic-linear model to a single file&#39;s data.  Arguments:</p><ul><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>path_to_data::String</code>: Path to the folder containing the data.</li><li><code>path_to_annotation::String</code>: Path to the annotation of the wells.</li></ul><p>Key Arguments:</p><ul><li><code>path_to_results= &quot;NA&quot;</code>: Path to save the results.</li><li><code>path_to_plot= &quot;NA&quot;</code>: Path to save the plots.</li><li><code>do_plot=false</code>: Whether to generate and visualize plots of the data.</li><li><code>verbose=false</code>: Whether to enable verbose output.</li><li><code>write_res= false</code>: Whether to write results.</li><li><code>pt_avg=7</code>: Number of points to use for smoothing average.</li><li><code>pt_smoothing_derivative=7</code>:  Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>pt_min_size_of_win=7</code>: Minimum size of the exponential windows in number of smoothed points.</li><li><code>type_of_win=&quot;maximum</code>: How the exponential phase window is selected (&quot;maximum&quot; or &quot;global_thr&quot;).</li><li><code>threshold_of_exp=0.9</code>: Threshold of growth rate in quantile to define the exponential windows.</li><li><code>blank_subtraction=&quot;avg_blank&quot;</code>: How to use blank data for subtraction (options: &quot;NO&quot;, &quot;avg<em>subtraction&quot;, &quot;time</em>avg&quot;).</li><li><code>fit_replicate=false</code>: If <code>true</code>, fit the average between replicates; if <code>false</code>, fit all replicates independently.</li><li><code>correct_negative=&quot;thr_correction</code>: Method to correct negative values (options: &quot;thr<em>correction&quot;, &quot;blank</em>correction&quot;).</li><li><code>thr_negative=0.01</code>: Threshold value used only if <code>correct_negative == &quot;thr_correction&quot;</code>.</li><li><code>multiple_scattering_correction=false</code>: Whether or not correct the data with a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li></ul><p>Output:</p><ul><li>a matrix wich each column has  the following contents:</li></ul><p><code>results_lin_log_fit[:,1] = [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]</code>. It can be saved into a .csv if <code>write_res=true</code>.</p><ul><li>The plots of the log-linear fitting and of the dynamics of specific growth rate if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;ODE-one-well&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-ODE-function-for-one-well"><a class="docs-heading-anchor" href="#Fitting-ODE-function-for-one-well">Fitting ODE function for one well</a><a id="Fitting-ODE-function-for-one-well-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-ODE-function-for-one-well" title="Permalink"></a></h2><pre><code class="language-julia hljs"> fitting_one_well_ODE_constrained(data::Matrix{Float64},
    name_well::String, 
    label_exp::String,
    model::String,
    lb_param::Vector{Float64}, 
    ub_param::Vector{Float64}; 
    param= lb_param .+ (ub_param.-lb_param)./2,
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), 
    integrator =KenCarp4(autodiff=true), 
    do_plot=false, 
    path_to_plot=&quot;NA&quot;, 
    pt_avg=1, 
    pt_smooth_derivative=7,
    smoothing=false,
    type_of_loss=&quot;RE&quot;,
    blank_array=zeros(100),
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot; ,
 PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001
    )</code></pre><p>This function performs constrained parameter fitting on a single well&#39;s dataset using an ordinary differential equation (ODE) model. It estimates the model parameters within specified lower and upper bounds.</p><p>Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see <a href="#data">data formatting</a>.</li><li><code>model::String</code>: ODE model to use</li><li><code>name_well::String</code>: Name of the well.</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p>Key Arguments:</p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>: Initial guess for the model parameters.</li><li>`integrator =KenCarp4(autodiff=true)&#39; sciML integrator</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO</li><li><code>do_plot=true</code>: Whether to generate plots or not.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the plots.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;)</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>verbose=false</code>: Whether to enable verbose output.</li><li><code>write_res=true</code>: Whether to write results.</li><li><code>multiple_scattering_correction=false</code>: Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>results_ODE_fit =fitting_one_well_ODE_constrained(...)</code>:</p><ul><li><code>results_ODE_fit[1]</code> an array with the following contents: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code></li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param<em>n&quot; &#39; are the parameter of the selected ODE as in this [table](#ODE</em>list)</p><ul><li><p><code>results_ODE_fit[2]</code> the times of the fitted ODE</p></li><li><p><code>results_ODE_fit[3]</code> the numerical solution of the fitted ODE</p></li><li><p>The plot of the  fitting  if <code>do_plot=true</code></p></li></ul><p>&lt;a name=&quot;ODE-file&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-ODE-function-for-one-file"><a class="docs-heading-anchor" href="#Fitting-ODE-function-for-one-file">Fitting ODE function for one file</a><a id="Fitting-ODE-function-for-one-file-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-ODE-function-for-one-file" title="Permalink"></a></h2><pre><code class="language-julia hljs">   fit_file_ODE(
    label_exp::String,
    path_to_data::String,
    path_to_annotation::String,
    model::String, 
    lb_param::Vector{Float64},
    ub_param::Vector{Float64}; 
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(),
    integrator = KenCarp4(autodiff=true), 
    path_to_results=&quot;NA&quot;,
    path_to_plot=&quot;NA&quot;, 
    loss_type=&quot;RE&quot;, 
    smoothing=false, 
    do_plot=false,
    verbose=false, 
    write_res=false, 
    pt_avg=1, 
    pt_smooth_derivative=7,
    blank_subtraction=&quot;avg_blank&quot;, 
    fit_replicate=false, 
    correct_negative=&quot;thr_correction&quot;,
    thr_negative=0.01, 
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot; ,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001 
    )</code></pre><p>This function fits an ordinary differential equation (ODE) model to a single file&#39;s data. </p><p>Arguments:</p><ul><li><code>path_to_data::String</code>: path to the csv file of data</li><li><code>path_to_annotation::String</code> path to the annotation of the dataset</li><li><code>model::String</code>: ODE model to use</li><li><code>label_exp::String</code>: Label of the experiment.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds of the model parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds of the model parameters.</li></ul><p>Key Arguments:</p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>: Initial guess for the model parameters.</li><li>`integrator =KenCarp4(autodiff=true)&#39; sciML integrator</li><li><code>optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited()</code> optimizer from optimizationBBO</li><li><code>do_plot=true</code>: Whether to generate plots or not.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the plots.</li><li><code>pt_avg=7</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=false</code>: Whether to apply smoothing to the data or not.</li><li><code>type_of_loss:=&quot;RE&quot;</code>: Type of loss function to be used. (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;)</li><li><code>blank_array=zeros(100)</code>: Data of all blanks in single array.</li><li><code>verbose=false</code>: Whether to enable verbose output.</li><li><code>write_res=true</code>: Whether to write results.</li><li><code>multiple_scattering_correction=false</code>: Whether or not correct the data qith a calibration curve.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path where the .csv calibration data are located, used only if <code>multiple_scattering_correction=true</code>.</li><li>fit_replicate=false,  if true the average between replicates is fitted.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>results_ODE_fit =fit_file_ODE(...)</code>:</p><ul><li><code>results_ODE_fit[1]</code> a matrix with the following contents for each column: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code>. It can be saved into a .csv if <code>write_res=true</code>.</li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param<em>n&quot; &#39; are the parameter of the selected ODE as in this [table](#ODE</em>list)</p><ul><li>The plot of the  fitting  if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;custom-ODE&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-custom-ODE-function-for-one-well"><a class="docs-heading-anchor" href="#Fitting-custom-ODE-function-for-one-well">Fitting custom ODE function for one well</a><a id="Fitting-custom-ODE-function-for-one-well-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-custom-ODE-function-for-one-well" title="Permalink"></a></h2><pre><code class="language-julia hljs">fitting_one_well_custom_ODE(data::Matrix{Float64},
    name_well::String, 
    label_exp::String,
    model::Any, 
    lb_param::Vector{Float64}, 
    ub_param::Vector{Float64},
    n_equation::Int; 
    param= lb_param .+ (ub_param.-lb_param)./2,
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), 
    integrator =KenCarp4(autodiff=true),
    do_plot=false, 
    path_to_plot=&quot;NA&quot;, 
    pt_avg=1, 
    pt_smooth_derivative=7,
    smoothing=false, 
    type_of_loss=&quot;RE&quot;, 
    blank_array=zeros(100), 
    multiple_scattering_correction=false,
    calibration_OD_curve=&quot;NA&quot;  ,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001
    )</code></pre><p>This function is designed for fitting an ordinary differential equation (ODE) model to a dataset representing the growth curve of a microorganism in a well. It utilizes a customizable ODE model, optimization methods, and integration techniques for parameter estimation.</p><p>Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see <a href="#data">data formatting</a>.</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>model::Any</code>: The ODE model to use.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds for the parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds for the parameters.</li><li><code>n_equation::Int</code>: The number of ODEs in the system.</li></ul><p>Output (if <code>results_ODE_fit =fitting_one_well_custom_ODE(...)</code>:</p><ul><li><code>results_ODE_fit[1]</code> a matrix with the following contents for each column: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code>. It can be saved into a .csv if <code>write_res=true</code>.</li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param<em>n&quot; &#39; are the parameter of the selected ODE as in this [table](#ODE</em>list)</p><ul><li>The plot of the  fitting  if <code>do_plot=true</code></li></ul><p>Key   Arguments:</p><ul><li><code>param= lb_param .+ (ub_param.-lb_param)./2</code>: Initial guess for the parameters.</li><li><code>optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited()</code>: The optimization method to use.</li><li><code>integrator=KenCarp4(autodiff=true)</code>: The integrator for solving the ODE.</li><li><code>do_plot=false</code>: Whether to generate plots or not.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the generated plots.</li><li><code>pt_avg=1</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smooth_derivative=7</code>: Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>smoothing=false</code>: Determines whether smoothing is applied to the data.</li><li><code>type_of_loss=&quot;RE&quot;</code>: Type of loss used for optimization (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;)</li><li><code>blank_array=zeros(100)</code>: Data representing blanks for correction.</li><li><code>multiple_scattering_correction=false</code>: If <code>true</code>, uses a given calibration curve to correct the data.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path to the calibration curve used for data correction.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>&lt;a name=&quot;Sensitivity-analysis&quot;&gt;&lt;/a&gt;</p><h2 id="Sensitivity-analysis"><a class="docs-heading-anchor" href="#Sensitivity-analysis">Sensitivity analysis</a><a id="Sensitivity-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-analysis" title="Permalink"></a></h2><pre><code class="language-julia hljs"> one_well_morris_sensitivity(data::Matrix{Float64}, 
    name_well::String,
    label_exp::String, 
    model::String, 
    lb_param::Vector{Float64}, 
    ub_param::Vector{Float64}; 
    N_step_morris =7,
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), 
    integrator =KenCarp4(autodiff=true), 
    pt_avg=1, 
    pt_smooth_derivative=7,
    write_res=false,
    smoothing=false,
    type_of_loss=&quot;RE&quot;, 
    blank_array=zeros(100),
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot;  ,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001
    )</code></pre><p>This function is designed to perform Morris sensitivity analysis on a dataset representing the growth curve of a microorganism in a well. It assesses the sensitivity of the model to variations in input parameters of the optimization.</p><p>Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>model::String</code>: The ODE model to use.</li><li><code>lb_param::Vector{Float64}</code>: Lower bounds for the parameters.</li><li><code>ub_param::Vector{Float64}</code>: Upper bounds for the parameters.</li></ul><p>Key Arguments:</p><ul><li><code>N_step_morris=7</code>: Number of steps for the Morris sensitivity analysis.</li><li><code>optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited()</code>: The optimization method to use.</li><li><code>integrator=KenCarp4(autodiff=true)</code>: The integrator for solving the ODE.</li><li><code>pt_avg=1</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>pt_smooth_derivative=7</code>: Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>write_res=false</code>: If <code>true</code>, writes the sensitivity analysis results to a file.</li><li><code>smoothing=false</code>: Determines whether smoothing is applied to the data.</li><li><code>type_of_loss=&quot;RE&quot;</code>: Type of loss used for optimization (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;)</li><li><code>blank_array=zeros(100)</code>: Data representing blanks for correction.</li><li><code>multiple_scattering_correction=false</code>: If <code>true</code>, uses a given calibration curve to correct the data.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path to the calibration curve used for data correction.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>results_ODE_morris_sensitivity =one_well_morris_sensitivity(...)</code>:</p><ul><li><code>results_ODE_morris_sensitivity[1]</code> a with in each column the initial guess for the parameters of the optimization in the same order of <a href="#ODE_list">table</a></li><li><code>results_ODE_morris_sensitivity[2]</code> a matrix with the following contents for each column: <code>[&quot;name of model&quot;, &quot;well&quot;, &quot;param_1&quot;,&quot;param_2&quot;,..,&quot;param_n&quot;,&quot;maximum specific gr using ode&quot;,&quot;maximum specific gr using data&quot;, &quot;objective function value (i.e. loss of the solution)&quot;]</code>. It can be saved into a .csv if <code>write_res=true</code>.</li></ul><p>where &#39; &quot;param<em>1&quot;,&quot;param</em>2&quot;,..,&quot;param<em>n&quot; &#39; are the parameter of the selected ODE as in this [table](#ODE</em>list)</p><ul><li>The plot of the  fitting  if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;Model-selection&quot;&gt;&lt;/a&gt;</p><h2 id="Model-selection"><a class="docs-heading-anchor" href="#Model-selection">Model selection</a><a id="Model-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Model-selection" title="Permalink"></a></h2><pre><code class="language-julia hljs">ODE_Model_selection(data::Matrix{Float64}, 
    name_well::String, 
    label_exp::String,
    models_list::Vector{String}, 
    lb_param_array::Any,
    ub_param_array::Any; 
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), 
    integrator = KenCarp4(autodiff=true), 
    pt_avg = 1 , 
    beta_penality = 2.0, 
    smoothing= false, 
    type_of_loss=&quot;L2&quot;,
    blank_array=zeros(100), 
    plot_best_model=false, 
    path_to_plot=&quot;NA&quot;,
    pt_smooth_derivative=7,
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot;, 
    verbose=false,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001
)</code></pre><p>This function performs model selection based on a dataset representing the growth curve of a microorganism in a well. It evaluates multiple ODE models and selects the best-fitting model using the Akaike Information Criterion (AIC).</p><p>Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>models_list::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>lb_param_array::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>ub_param_array::Any</code>: Upper bounds for the parameters (compatible with the models).</li></ul><p>Key Arguments:</p><ul><li><code>optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited()</code>: The optimization method to use.</li><li><code>integrator=KenCarp4(autodiff=true)</code>: The integrator for solving the ODE.</li><li><code>pt_avg=1</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>beta_penality=2.0</code>: Penalty for AIC evaluation.</li><li><code>smoothing=false</code>: Determines whether smoothing is applied to the data.</li><li><code>type_of_loss=&quot;L2&quot;</code>: Type of loss used for optimization (options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;)</li><li><code>blank_array=zeros(100)</code>: Data representing blanks for correction.</li><li><code>plot_best_model=false</code>: If <code>true</code>, the results of the best-fit model will be plotted.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the generated plots.</li><li><code>pt_smooth_derivative=7</code>: Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>multiple_scattering_correction=false</code>: If <code>true</code>, uses a given calibration curve to correct the data.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path to the calibration curve used for data correction.</li><li><code>verbose=false</code>: If <code>true</code>, enables verbose output.</li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>Model_selection =ODE_Model_selection(...)</code>:</p><ul><li><code>Model_selection[1]</code> a Matrix containing the loss and the AIC score for each model.</li><li><code>Model_selection[2]</code> a Tuple containing all the fitted models.</li><li><code>Model_selection[3]</code> the AIC score of the best model</li><li><code>Model_selection[4]</code> , the loss of the best model</li><li><code>Model_selection[5]</code> , the parameter of the best model</li><li><code>Model_selection[6]</code> , the string of the best model</li><li><code>Model_selection[7]</code> , the numerical solution of the fitted ODE</li><li>The plot of the  fitting of the best model if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;cdp&quot;&gt;&lt;/a&gt;</p><h2 id="Change-point-detection"><a class="docs-heading-anchor" href="#Change-point-detection">Change point detection</a><a id="Change-point-detection-1"></a><a class="docs-heading-anchor-permalink" href="#Change-point-detection" title="Permalink"></a></h2><pre><code class="language-julia hljs">cpd_local_detection(data::Matrix{Float64},
    n_max_cp::Int;
    type_of_detection=&quot;lsdd&quot;,
    type_of_curve=&quot;original&quot;, 
    pt_derivative = 0,
    size_win =2,
method= &quot;peaks_prominence&quot;,
number_of_bin = 40)
</code></pre><p>This function performs change point detection on a dataset, identifying local changes in the growth curve. It uses various algorithms based on user-defined parameters.</p><p>Arguments:</p><ul><li><code>data::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>n_max_cp::Int</code>: The maximum number of change points to detect.</li></ul><p>Key Arguments:</p><ul><li><code>type_of_detection=&quot;lsdd&quot;</code>: Type of change point detection algorithm. Options are &quot;lsdd&quot; or piecewise linear fitting </li><li><code>type_of_curve=&quot;deriv&quot;</code>: Type of curve used for the change point detection. Options are &quot;deriv&quot; for the  derivative/specific gr or &quot;original&quot; for growth curve.</li><li><code>pt_derivative=0</code>: Number of points to evaluate the derivative or specific growth rate. If 0, numerical derivative is used; if &gt;1, specific growth rate is calculated with the given window size.</li><li><code>size_win=2</code>: Size of the sliding window used in all detection methods.</li><li><code>method = &quot;peaks_prominence&quot;</code> : method to detect peak on the dissimilarity curve. Option &quot;peaks<em>prominence&quot; use prominece of peaks to score them. `&quot;thr</em>scan&quot;` grid scan with a threshold to detect peaks.</li><li><code>number_of_bin = 40</code>: number of bins for the grid search. used only if <code>method = &quot;thr_scan&quot;</code></li></ul><p>Output (if <code>cdps =cpd_local_detection(...)</code>:</p><ul><li><code>cdps[1]</code> Indexes of the detected change points</li></ul><p>&lt;a name=&quot;cdp-fixed&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-segmented-ODE-with-fixed-change-point-number"><a class="docs-heading-anchor" href="#Fitting-segmented-ODE-with-fixed-change-point-number">Fitting segmented ODE with fixed change-point number</a><a id="Fitting-segmented-ODE-with-fixed-change-point-number-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-segmented-ODE-with-fixed-change-point-number" title="Permalink"></a></h2><pre><code class="language-julia hljs">selection_ODE_fixed_change_points(data_testing::Matrix{Float64}, 
    name_well::String,
    label_exp::String,
    list_of_models::Vector{String}, 
    list_lb_param::Any,
    list_ub_param::Any, 
    n_change_points::Int;
    type_of_loss=&quot;L2&quot;, 
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), 
    integrator = KenCarp4(autodiff=true), 
    type_of_detection =  &quot;lsdd&quot;,
    type_of_curve = &quot;original&quot;, 
    smoothing=false,
    pt_avg=1,
    do_plot=false, 
    path_to_plot=&quot;NA&quot;, 
    win_size=2, 
    pt_smooth_derivative=0,
    multiple_scattering_correction=false, 
    calibration_OD_curve=&quot;NA&quot;,
    beta_smoothing_ms = 2.0,
method_peaks_detection= &quot;peaks_prominence&quot;,
n_bins = 40,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001
    )</code></pre><p>This function performs model selection for ordinary differential equation (ODE) models while considering fixed change points in a growth curve dataset. It allows for the evaluation of multiple ODE models and considers a specified number of change points.</p><p>Arguments:</p><ul><li><code>data_testing::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>list_of_models::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>list_lb_param::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>: Upper bounds for the parameters (compatible with the models).</li></ul><p>Key Arguments:</p><ul><li><code>n_change_points::Int</code>: The number of fixed change points to consider.</li><li><code>type_of_loss=&quot;L2&quot;</code>: Type of loss used for optimization(options= &quot;RE&quot;, &quot;L2&quot;, &quot;L2<em>derivative&quot; and &quot;blank</em>weighted_L2&quot;).</li><li><code>optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited()</code>: The optimization method to use.</li><li><code>integrator=KenCarp4(autodiff=true)</code>: The integrator for solving the ODE.</li><li><code>type_of_detection=&quot;lsdd&quot;</code>: Type of change point detection algorithm. Options are &quot;lsdd&quot; or piecewise linear fitting </li><li><code>type_of_curve=&quot;original&quot;</code>: Type of curve used for the change point detection. Options are &quot;deriv&quot; for the  derivative/specific gr or &quot;original&quot; for growth curve.</li><li><code>smoothing=false</code>: Determines whether smoothing is applied to the data.</li><li><code>pt_avg=1</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>do_plot=false</code>: Whether to generate plots or not.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the generated plots.</li><li><code>win_size=2</code>: Number of points for the  window of the change point detection algorithm.</li><li><code>pt_smooth_derivative=0</code>: Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>multiple_scattering_correction=false</code>: If <code>true</code>, uses a given calibration curve to correct the data.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path to the calibration curve used for data correction.</li><li><code>beta_smoothing_ms=2.0</code>: Penality parameter of the Akaike Information Criterion (AIC) penalty.</li><li><code>method_peaks_detection = &quot;peaks_prominence&quot;</code> : method to detect peak on the dissimilarity curve. Option &quot;peaks<em>prominence&quot; use prominece of peaks to score them. `&quot;thr</em>scan&quot;` grid scan with a threshold to detect peaks.</li><li><code>n_bins = 40</code>: number of bins for the grid search. used only if <code>method_peaks_detection = &quot;thr_scan&quot;</code></li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>res =selection_ODE_fixed_change_points(...)</code>:</p><ul><li><code>res[1]</code>. Parameters of each segment</li><li><code>res[2]</code>. Interval of the ODE segment</li><li><code>res[3]</code>. Time of the fitted solution</li><li><code>res[4]</code>. Numerical fitted solution</li><li>The plot of the  fitting if <code>do_plot=true</code></li></ul><p>&lt;a name=&quot;cdp-search&quot;&gt;&lt;/a&gt;</p><h2 id="Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points"><a class="docs-heading-anchor" href="#Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points">Fitting segmented ODE with direct search for a maximum number of change-points</a><a id="Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points" title="Permalink"></a></h2><pre><code class="language-julia hljs">ODE_selection_NMAX_change_points(data_testing::Matrix{Float64}, 
    name_well::String, 
    label_exp::String, 
    list_lb_param::Any, 
    list_ub_param::Any, 
    list_of_models::Vector{String}, 
    n_max_change_points::Int; 
    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(),  
    integrator = KenCarp4(autodiff=true),
    type_of_loss=&quot;L2&quot;, # type of used loss 
    type_of_detection =  &quot;lsdd&quot;,
    type_of_curve = &quot;original&quot;, 
    pt_avg = 1 , 
    smoothing= true, 
    do_plot=false, 
    path_to_plot=&quot;NA&quot;, 
    path_to_results=&quot;NA&quot;,
    win_size=2, 
    pt_smooth_derivative=7,
    penality_parameter=2.0,
    multiple_scattering_correction=&quot;false&quot;, 
    calibration_OD_curve=&quot;NA&quot;,  
   save_all_model=false,
    method_peaks_detection= &quot;peaks_prominence&quot;,
    n_bins = 40,
   PopulationSize =100,
          maxiters = 10000,
           abstol = 0.001 )</code></pre><p>This function fits segmented ordinary differential equation (ODE) models to a growth curve dataset using direct search for a maximum number of change-points. It allows for the evaluation of multiple ODE models with a varying number of change-points.</p><p>Arguments:</p><ul><li><code>data_testing::Matrix{Float64}</code>: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD) or fluorescence.</li><li><code>name_well::String</code>: The name of the well.</li><li><code>label_exp::String</code>: The label of the experiment.</li><li><code>list_lb_param::Any</code>: Lower bounds for the parameters (compatible with the models).</li><li><code>list_ub_param::Any</code>: Upper bounds for the parameters (compatible with the models).</li><li><code>list_of_models::Vector{String}</code>: A vector of ODE models to evaluate.</li><li><code>n_max_change_points::Int</code>: The maximum number of change-points to consider.</li></ul><p>Key Arguments:</p><ul><li><code>optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited()</code>: The optimization method to use.</li><li><code>integrator=KenCarp4(autodiff=true)</code>: The integrator for solving the ODE.</li><li><code>type_of_loss=&quot;L2&quot;</code>: Type of loss used for optimization (options: &quot;L2&quot; for squared loss).</li><li><code>type_of_detection=&quot;lsdd&quot;</code>: Type of change point detection algorithm. Options are &quot;lsdd&quot; for piecewise linear fitting on the specific growth rate.</li><li><code>type_of_curve=&quot;original&quot;</code>: Type of curve used for the change point detection. Options are &quot;deriv&quot; for the  derivative/specific gr or &quot;original&quot; for growth curve.</li><li><code>pt_avg=1</code>: Number of points to generate the initial condition or do the rolling avg smoothing.</li><li><code>smoothing=true</code>: Determines whether smoothing is applied to the data.</li><li><code>do_plot=false</code>: Whether to generate plots or not.</li><li><code>path_to_plot=&quot;NA&quot;</code>: Path to save the generated plots.</li><li><code>path_to_results=&quot;NA&quot;</code>: Path to save the fitting results.</li><li><code>win_size=2</code>: Number of points for the  window of the change point detection algorithm.</li><li><code>pt_smooth_derivative=0</code>: Number of points for evaluation of specific growth rate. If &lt;2 it uses interpolation algorithm otherwise a sliding window approach.</li><li><code>penality_parameter=2.0</code>: Parameter for penalizing the change in the number of parameters.</li><li><code>multiple_scattering_correction=false</code>: If <code>true</code>, uses a given calibration curve to correct the data.</li><li><code>calibration_OD_curve=&quot;NA&quot;</code>: The path to the calibration curve used for data correction.</li><li><code>save_all_model=false</code>: If <code>true</code>, saves fitting results for all evaluated models.</li><li><code>method_peaks_detection = &quot;peaks_prominence&quot;</code> : method to detect peak on the dissimilarity curve. Option &quot;peaks<em>prominence&quot; use prominece of peaks to score them. `&quot;thr</em>scan&quot;` grid scan with a threshold to detect peaks.</li><li><code>n_bins = 40</code>: number of bins for the grid search. used only if <code>method_peaks_detection = &quot;thr_scan&quot;</code></li><li><code>PopulationSize =100</code>: Size of the population of the optimization</li><li><code>maxiters = 10000</code>: stop criterion, the optimization is stopped when the number of iteration is bigger than <code>abstol</code></li><li><code>abstol = 0.001</code>: stop criterion, the optimization is stopped when the loss is lesser than <code>abstol</code></li></ul><p>Output (if <code>res =ODE_selection_NMAX_change_points(...)</code>:</p><ul><li><code>res[1]</code>. The  parameters of each segment of the top model</li><li><code>res[2]</code>. Time of the fitted solution</li><li><code>res[3]</code>. Numerical fitted solution</li><li>The plot of the  fitting if <code>do_plot=true</code></li><li>If <code>save_all_model=true</code> the best segnmented model is saved for each number of change points between 0 and <code>n_max_change_points</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../02_data/">« Data and annotation formatting</a><a class="docs-footer-nextpage" href="../04_math/">The mathematical models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 15 May 2024 16:33">Wednesday 15 May 2024</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
